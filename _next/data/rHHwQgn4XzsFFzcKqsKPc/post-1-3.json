{"pageProps":{"postData":{"id":"post-1-3","title":"Fixture Monkey With Kotlin","category":"test","thumbnail":"https://i.imgur.com/J5SIYtU.png","tags":"test","date":"2024-03-03 10:00","searchKeywords":"fixture monkey, test, fixture","description":"fixtureMonkey","preview":"\n테스트를 작성하다보면 프로덕션 코드를 작성하는 시간보다 테스트를 위한 픽스처를 만드는데 더 많은 시간이 소요될 때가 있다.\n\n테스트를 작성하는데 시간이 많이 들고 번거로울 수록 테스트 코드를 생략하게 되고 결국 결함에 취약한 시스템을 구현할 위험이 "},"detail":"\n테스트를 작성하다보면 프로덕션 코드를 작성하는 시간보다 테스트를 위한 픽스처를 만드는데 더 많은 시간이 소요될 때가 있다.\n\n테스트를 작성하는데 시간이 많이 들고 번거로울 수록 테스트 코드를 생략하게 되고 결국 결함에 취약한 시스템을 구현할 위험이 있다.\n\n주문 관련 로직을 테스트 하기위해서 `Order` 픽스처를 만들어야했었는데 `Order` 객체 내부에 필드가 24개 였을뿐더러 내부 객체의 필드까지 합하면 정의해줘야 하는 필드가 수 없이 많았다.\n\n심지어 케이스마다 다른 상태값을 갖고있는 `Order` 픽스처를 추가로 만들어줘야 했기 때문에 테스트 준비에 많은 시간이 소요됐던 경험이 있다.\n\n그러던중 `Fixture Monkey`라는 PBT(Property Based Testing) 라이브러리를 알게되었고, `Fixture Monkey`를 사용하여 테스트를 편리하게 작성할 수 있었던 경험이 있었는데, 개인적으로 유용하게 사용했던 핵심 내용만 간략하게 소개하고자 한다.\n\n## FixtureMonkey의 주요 기능\n\n- 렌덤하고 복잡한 제약조건을 갖는 객체를 생성해준다.\n- 설정한 제약조건을 검증할 수 있다.\n- 테스트케이스마다 다르게 객체 제어가 가능하다.\n\n`FixtureMonkey`는 엔티티 필드에 지정된 Bean validation 어노테이션에 따라 유효한 속성값을 갖는 객체를 생성한다.\n\n실패 테스트 작성과 같이 특정 테스트 케이스에서 조건을 추가하거나 조건에 벗어난 필드를 설정해야할 경우에는 `ArbitraryBuilder`를 사용하여 fixture를 제어할 수 있다.\n\n`ArbitraryBuilder`는 빌더 패턴을 사용하여 객체의 필드값을 원하는 값으로 설정하여 객체를 생성하는게 가능하다.\n\n## 예제\n\n### Without FixtureMonkey Test\n\n`FixtureMonkey`의 편리한 기능을 살펴보기에 앞서서 이전 방식으로 테스트를 작성해보았다.\n\n다음은 주문 과정에서 입력된 배송지 주소가 유효한지 검증하는 테스트이다.\n\n```kotlin\ndata class Order(  \n    val product: List<Product>,  \n    val purchaserName: String,  \n    val receiver: Receiver,  \n    val totalPrice: Long,  \n    val coupon: List<Coupon>,  \n    val delivery: Delivery,  \n)\n```\n\n```kotlin\nclass OrderFixture {  \n    companion object {  \n        fun create(  \n            id: Long = 1L,  \n            product: List<Product> = listOf(  \n                Product(name = \"초콜릿\", price = 300L),  \n                Product(name = \"키보드\", price = 20000L),  \n            ),  \n            purchaserName: String = \"홍길동\",  \n            receiver: Receiver = Receiver(name = \"홍길동\", \"01012341234\"),  \n            totalPrice: Long = 20300L,  \n            coupon: List<Coupon> = listOf(Coupon()),  \n            delivery: Delivery = Delivery(\"경기도\", \"203동 1023호\", true),  \n        ): Order {  \n            return Order(  \n                id = id,  \n                product = product,  \n                purchaserName = purchaserName,  \n                receiver = receiver,  \n                totalPrice = totalPrice,  \n                coupon = coupon,  \n                delivery = delivery,  \n            )  \n        }  \n    }  \n}\n```\n\n```kotlin\nclass OrderServiceTestWithOutFixtureMonkey : DescribeSpec({  \n    val sut = OrderService()  \n    val log = LoggerFactory.getLogger(this.javaClass)  \n  \n    describe(\"배송 주소 유효성 검사\") {  \n        it(\"유효성 검증을 통과한다.\") {  \n            val order = OrderFixture.create()  \n  \n            shouldNotThrowAny {  \n                sut.validateDeliveryAddress(order)  \n            }  \n        }  \n        it(\"지번 주소를 입력받았을 경우, 상세 주소가 없으면 안 된다\") {  \n            val order = OrderFixture.create(delivery = Delivery(baseAddress = \"경기도\", road = false, detailAddress = null))  \n  \n            val exception = shouldThrow<IllegalArgumentException> {  \n                sut.validateDeliveryAddress(order)  \n            }  \n  \n            exception.message shouldBe \"지번 주소에는 상세 주소가 반드시 필요합니다.\"  \n        }  \n    }})\n```\n\n테스트 성공과 실패 케이스를 위한 `OrderFixture` 객체를 정의하여 사용하였다.\n`Order` 객체에 정의된 필드 뿐만 아니라 연관된 객체의 필드값들도 함께 정의해줘야하기 때문에 꽤나 번거로운 작업일 수 있다.\n\n만약 연관된 엔티티가 더 많고 정의해줘야하는 필드 수가 훨씬 많아진다면 테스트를 위한 fixture를 정의하는데 큰 비용이 소모되게 된다.\n\n### FixtureMonkey Test\n\n이번엔 `FixtureMonkey`를 사용하여 간단하게 fixture를 생성하여 테스트를 작성해보도록 하겠다.\n\n먼저 `build.gradle.kts`에 의존성을 추가해주었다.\n```gradle\n// fixture monkey  \ntestImplementation(\"com.navercorp.fixturemonkey:fixture-monkey-starter-kotlin:1.0.14\")  \ntestImplementation(\"com.navercorp.fixturemonkey:fixture-monkey-jakarta-validation:0.6.3\")  \ntestImplementation(\"com.navercorp.fixturemonkey:fixture-monkey-jackson:0.6.3\")\n```\n\n**DefaultMonkeyCreator**\n```kotlin\nfun monkey() : FixtureMonkey {  \n    return FixtureMonkey.builder()  \n        .plugin(KotlinPlugin())  \n        .build()  \n}\n```\n\n**FixtureBuilders**\n```kotlin\nfun <T> defaultFixtureBuilder(clazz: Class<T>): ArbitraryBuilder<T> {  \n    return monkey().giveMeBuilder(clazz)  \n}\n```\n\n```kotlin\nclass OrderServiceTestWithFixtureMonkey: DescribeSpec({  \n    val sut = OrderService()  \n    val log = LoggerFactory.getLogger(this.javaClass)  \n  \n    describe(\"배송 주소 유효성 검사\") {  \n        it(\"유효성 검증을 통과한다.\") {  \n            val order = defaultFixtureBuilder(Order::class.java)  \n                .setExp(  \n                    Order::delivery,  \n                    Delivery(baseAddress = \"경기도\", detailAddress = null, road = true))  \n                .sample()  \n  \n            shouldNotThrowAny {  \n                sut.validateDeliveryAddress(order)  \n            }  \n        }  \n        it(\"지번 주소를 입력받았을 경우, 상세 주소가 없으면 안 된다\") {  \n            val order = defaultFixtureBuilder(Order::class.java)  \n                .setExp(  \n                    Order::delivery,  \n                    Delivery(baseAddress = \"경기도\", detailAddress = null, road = false))  \n                .sample()  \n  \n            val exception = shouldThrow<IllegalArgumentException> {  \n                sut.validateDeliveryAddress(order)  \n            }  \n  \n            exception.message shouldBe \"지번 주소에는 상세 주소가 반드시 필요합니다.\"  \n        }  \n    }})\n```\n\n이처럼 `FixtureMonkey`를 사용하면 랜덤한 필드값을 갖는 fixture 객체를 생성하여 사용할 수 있다.\n\n`setter`를 통해서 객체를 제어할 수 있는데, 테스트하고자 하는 필드를 명확히 표현하기 때문에 테스트 관심사를 바로 파악할 수 있다는 장점도 있다.\n"},"__N_SSG":true}