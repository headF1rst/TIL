{"pageProps":{"postData":{"id":"post-2-3","title":"조인 테이블이 왜 생기지? @JoinColumn으로 해결하는 연관관계 매핑의 비밀","category":"JPA","thumbnail":"https://velog.velcdn.com/images/wooyong99/post/6fdebd14-5fe8-4959-b085-74edb6bc4d46/image.png","tags":"JPA","date":"2024-10-10 10:00","searchKeywords":"jpa, JoinColumn, 외래 키, 외래 키 제약 조건","description":"JoinColumn","preview":"\n`@JoinColumn`은 외래키를 매핑할 때 사용한다. 즉, 한 엔티티에서 다른 엔티티를 참조(조인)하는데 사용되는 필드를 지정하는 역할을 한다.\n\n```java\n@Entity  \n@Table(name = \"orders\")  \n@Getter\n@No"},"detail":"\n`@JoinColumn`은 외래키를 매핑할 때 사용한다. 즉, 한 엔티티에서 다른 엔티티를 참조(조인)하는데 사용되는 필드를 지정하는 역할을 한다.\n\n```java\n@Entity  \n@Table(name = \"orders\")  \n@Getter\n@NoArgsConstructor  \npublic class Order {  \n  \n    @Id  \n    @GeneratedValue(strategy = GenerationType.IDENTITY)  \n    private Long id;  \n  \n    @ManyToOne  \n    @JoinColumn(name = \"customer_id\") // 외래 키로 지정\n    private Customer customer;\n  \n    public Order(Customer customer) {  \n        this.customer = customer;  \n    }  \n}\n```\n\n```java\n@Entity  \n@Getter  \n@NoArgsConstructor  \npublic class Customer {  \n  \n    @Id  \n    @GeneratedValue(strategy = GenerationType.IDENTITY)  \n    private Long id;  \n  \n    private String name;  \n  \n    public Customer(String name) {  \n        this.name = name;  \n    }  \n}\n```\n\n`@JoinColumn(name = \"customer_id\")`는 Order 테이블에서 `customer_id`라는 컬럼을 통해 `Customer` 엔티티를 참조하는 외래 키를 정의한다.\n\n`@ManyToOne`의 기본 FetchType이 EAGER이기 때문에, Order 조회시 연관된 Customer 엔티티도 함께 `@JoinColumn`에 명시된 필드를 통해 참조(조인)하여 가져오는걸 볼 수 있다.\n\n```java\n@SpringBootTest  \nclass OrderTest {  \n  \n    @Autowired  \n    private OrderRepository orderRepository;  \n    @Autowired  \n    private CustomerRepository customerRepository;  \n  \n    @Test  \n    void joinColumnTest() {  \n        var customer = customerRepository.save( new Customer(\"John Doe\"));  \n        var order = orderRepository.save(new Order(customer));  \n  \n        Order result = orderRepository.findById(order.getId()).get();  \n    }\n}\n```\n\n```\nHibernate: \n    select\n        o1_0.id,\n        c1_0.id,\n        c1_0.name \n    from\n        orders o1_0 \n    left join\n        customer c1_0 \n            on c1_0.id=o1_0.customer_id \n    where\n        o1_0.id=?\n```\n\n`@JoinColumn`은 ConstraintMode 옵션 값을 통해서 외래 키 제약 조건을 걸 수 있다.\n\n- **ConstraintMode.PROVIDER_DEFAULT** (기본값): JPA Provider의 외래 키 제약 조건 생성 전략을 따른다. Hibernate는 이 옵션 값에서 외래 키 제약 조건을 설정한다.\n- **ConstraintMode.CONSTRAINT**: 해당 외래 키 컬럼에 데이터베이스 레벨에서 외래 키 제약 조건을 설정한다.\n- **ConstraintMode.NO_CONSTRAIN**: DB에 외래키 제약조건을 걸지 않는다.\n    - 외래 키 컬럼은 생성되지만 DB가 그 컬럼의 값을 검증하거나 무결성을 유지하지는 않는다.\n\n# @JoinColumn은 생략해도 될까\n\n단방향 `@ManyToOne` 에선 `@JoinColumn`을 생략 할 수 있다. `@JoinColumn`을 생략하면 외래 키를 찾을 때 기본 전략을 사용한다. 실제로 앞의 예제 코드에서 `@JoinColumn`을 생략하고 테스트를 실행했을때 동일한 로그가 출력되는걸 확인할 수 있었다.\n\n> 기본 전략: 필드명 + _ + 참조하는 테이블의 컬럼명\n> \n> ex) customer + _ + id -> customer_id\n\n그러나 단방향 `@OneToMany` 연관관계에서 `@JoinColumn`을 생략할 경우, JPA는 조인 테이블을 생성하여 엔티티간의 관계를 관리한다.\n\n```java\n@Entity  \n@Table(name = \"orders\")  \n@Getter  \n@NoArgsConstructor  \npublic class Order {  \n  \n    @Id  \n    @GeneratedValue(strategy = GenerationType.IDENTITY)  \n    private Long id;  \n\n\t@Column(name = \"customer_id\")\n    private Long customerId;  \n  \n    public Order(Long customerId) {  \n        this.customerId = customerId;  \n    }  \n}\n```\n\n```java\n@Entity  \n@Getter  \n@NoArgsConstructor  \npublic class Customer {  \n  \n    @Id  \n    @GeneratedValue(strategy = GenerationType.IDENTITY)  \n    private Long id;  \n  \n    @OneToMany(cascade = CascadeType.ALL)  \n    private List<Order> orders = new ArrayList<>();\n  \n    private String name;  \n  \n    public Customer(String name) {  \n        this.name = name;  \n    }  \n}\n```\n\n```java\n@SpringBootTest  \nclass OrderTest {  \n  \n    @Autowired  \n    private OrderRepository orderRepository;  \n    @Autowired  \n    private CustomerRepository customerRepository;  \n  \n    @Test  \n\t@Transactional  \n\tpublic void joinColumnTest() {  \n\t    Customer customer = new Customer(\"John Doe\");  \n\t    List<Order> orders = List.of(\n\t\t    new Order(customer.getId()), \n\t\t    new Order(customer.getId())\n\t\t);\n\t    customer.getOrders().addAll(orders);  \n  \n\t    customerRepository.save(customer);  \n\t    orderRepository.saveAll(orders);  \n\t}\n}\n```\n\n테스트 실행 후 로그를 확인해보면 `customer_orders` 조인 테이블이 생성된것을 확인할 수 있다.\n\n![log](https://i.imgur.com/v332oJ2.png)\n\n# 왜 조인 테이블이 생성될까?\n\n단방향 `@OneToMany` 관계에서는 JPA가 어느 테이블에 외래 키를 두어야 할지 명확하지 않기 때문에, 중간 조인 테이블을 생성하여 관계를 관리한다.\n\n조인 테이블이 생성되는 것을 방지하고 싶다면, `@JoinColumn`을 명시적으로 설정하여 외래 키를 직접 관리하도록 해야 한다.\n아래와 같이 `@JoinColumn(name = \"customer_id\"...)`를 설정하여 외래키를 Order 테이블에 설정할 수 있다.\n\n```java\n@Entity  \n@Getter  \n@NoArgsConstructor  \npublic class Customer {  \n\t//...\n\t\n    @OneToMany(cascade = CascadeType.ALL)  \n    @JoinColumn(name = \"customer_id\", foreignKey = @ForeignKey(ConstraintMode.NO_CONSTRAINT))  \n    private List<Order> orders = new ArrayList<>();  \n  \n    //...\n}\n```\n\n다시 테스트를 실행하고 로그를 확인해 보면 조인 테이블이 생성되지 않은걸 확인할 수 있다.\n\n![log](https://i.imgur.com/1RLHtIp.png)\n\n---\n\n**참고 자료**\n- [@ManyToOne을 사용할 때 @JoinColumn 생략](https://hyeon9mak.github.io/omit-join-column-when-using-many-to-one/)\n\n"},"__N_SSG":true}