{"pageProps":{"postData":{"id":"post2","title":"통합 테스트에 @MockBean, @SpyBean을 남용하지 말자","category":null,"thumbnail":"https://images.velog.io/images/woo00oo/post/69f1c47c-686b-4d50-ba28-cd3eea7b92f4/%E1%84%8C%E1%85%A6%E1%84%86%E1%85%A9%E1%86%A8%E1%84%8B%E1%85%B3%E1%86%AF%20%E1%84%8B%E1%85%B5%E1%86%B8%E1%84%85%E1%85%A7%E1%86%A8%E1%84%92%E1%85%A2%E1%84%8C%E1%85%AE%E1%84%89%E1%85%A6%E1%84%8B%E1%85%AD._004.png","tags":"SpringBootTest, MockBean, SpyBean","date":"2025-02-28 10:00","preview":"\n좋은 테스트에 대해 이야기할 때, FIRST 원칙이 자주 거론된다.\n여기서 F는 Fast를 의미하는데, 좋은 테스트는 빠르게 동작해야하며 자주 실행할 수 있어야 한다 는 것을 의미한다.\n테스트가 느리면 피드백 주기가 길어지고 실행 빈도가 줄어들게 되"},"detail":"\n좋은 테스트에 대해 이야기할 때, FIRST 원칙이 자주 거론된다.\n여기서 F는 Fast를 의미하는데, 좋은 테스트는 빠르게 동작해야하며 자주 실행할 수 있어야 한다 는 것을 의미한다.\n테스트가 느리면 피드백 주기가 길어지고 실행 빈도가 줄어들게 되어 버그를 조기에 발견하기 어려워지며 개발 생산성이 떨어지게 된다.\n\n@SpringBootTest는 ApplicationContext에 있는 모든 Bean을 띄우기 때문에 테스트 실행에 많은 시간이 소요된다.\n\n만약 @SpringBootTest 마다 ApplicationContext를 띄우면 통합 테스트가 늘어남에 따라 테스트 실행 속도도 상당히 느려지게 될 것이다.\nSpring은 이러한 문제를 해결하고자 @SpringBootTest 등을 사용한 통합 테스트에서 [ContextCaching](https://docs.spring.io/spring-framework/reference/testing/testcontext-framework/ctx-management/caching.html)을 제공한다.\n\nSpring은 ApplicationContext를 캐싱하여 동일한 설정을 가진 테스트에서는 기존의 캐싱된 컨텍스트를 재사용하여 테스트 실행 속도를 최적화한다.\n\n## Context Caching 동작 방식\n\nSpring은 컨텍스트의 key를 생성하여, 이전에 생성된 컨텍스트가 캐시에 존재 하는지 확인하고 같은 키를 가진 컨텍스트가 있으면 재사용한다.\n\nSpring의 컨텍스트 캐싱 메커니즘은 다음과 같이 동작한다.\n\n### 1. MergedContextConfiguration 객체 생성\n\n테스트가 실행될 때 Spring은 해당 테스트의 설정을 기반으로 MergedContextConfiguration 객체를 생성한다.\nMergedContextConfiguration은 캐시 키로 사용되는 컨텍스트 설정 정보를 포함한 객체로 다음과 같은 정보를 포함한다.\n\n![](https://i.imgur.com/MUGHy8z.png)\n\n만약 @MockBean이나 @SpyBean을 사용할 경우 contextCustomimizers에 MockBeanCustomizer가 추가되면서 MergedContextConfiguration의 해시코드가 달라지게 된다.\n즉, ContextCache의 캐시 키가 달라지게 되면서 기존에 캐시된 ApplicationContext를 재사용하지 못하게 된다.\n\n```java\npublic abstract class AbstractTestContextBootstrapper implements TestContextBootstrapper {\n\n    private MergedContextConfiguration buildMergedContextConfiguration(\n        Class<?> testClass,\n        List<ContextConfigurationAttributes> configAttributesList,\n        @Nullable MergedContextConfiguration parentConfig,\n        CacheAwareContextLoaderDelegate cacheAwareContextLoaderDelegate,\n        boolean requireLocationsClassesOrInitializers) {\n\n        // 1. 설정 정보 수집을 위한 컨테이너\n        List<String> locations = new ArrayList<>();\n        List<Class<?>> classes = new ArrayList<>();\n        List<Class<?>> initializers = new ArrayList<>();\n\n        // 2. 각 설정 속성 처리\n        for (ContextConfigurationAttributes configAttributes : configAttributesList) {\n            ...\n            }\n        }\n\n        // 3. 추가 설정 수집\n        Set<ContextCustomizer> contextCustomizers = getContextCustomizers(testClass,\n            Collections.unmodifiableList(configAttributesList));\n\n        // 4. 프로퍼티 소스 처리\n        MergedTestPropertySources mergedTestPropertySources =\n            TestPropertySourceUtils.buildMergedTestPropertySources(testClass);\n\n        // 5. 최종 MergedContextConfiguration 생성\n        return new MergedContextConfiguration(\n            testClass,\n            StringUtils.toStringArray(locations),\n            ClassUtils.toClassArray(classes),\n            ApplicationContextInitializerUtils.resolveInitializerClasses(configAttributesList),\n            ActiveProfilesUtils.resolveActiveProfiles(testClass),\n            mergedTestPropertySources.getPropertySourceDescriptors(),\n            mergedTestPropertySources.getProperties(),\n            contextCustomizers,\n            contextLoader,\n            cacheAwareContextLoaderDelegate,\n            parentConfig);\n    }\n}\n```\n\n### 2. 캐시 키 생성\nMergedContextConfiguration 객체는 위의 설정 요소들을 조합하여 해시 코드를 생성하며 이 해시 코드는 캐시 키로 사용된다.\n\n```java\npublic class DefaultContextCache implements ContextCache {\n\n    private final Map<MergedContextConfiguration, ApplicationContext> contextMap =\n        Collections.synchronizedMap(new LruCache(32, 0.75f));\n        // ...\n}\n```\n\n### 3. 캐시 저장 및 조회\n\n새로운 테스트 실행 시, Spring은 먼저 현재 설정의 해시 키가 캐시에 존재하는지 확인한다.\n\n동일한 키가 존재하면 캐시된 컨텍스트를 반환하고, 존재하지 않으면 새로 ApplicationContext를 생성하여 캐시에 저장한다.\n\n```java\npublic class DefaultContextCache implements ContextCache {\n    ...\n    \n    @Override\n    @Nullable\n    public ApplicationContext get(MergedContextConfiguration key) {\n        Assert.notNull(key, \"Key must not be null\");\n        ApplicationContext context = this.contextMap.get(key);\n        if (context == null) {\n            this.missCount.incrementAndGet();\n        }\n        else {\n            this.hitCount.incrementAndGet();\n        }\n        return context;\n    }\n\n    @Override\n    public void put(MergedContextConfiguration key, ApplicationContext context) {\n        Assert.notNull(key, \"Key must not be null\");\n        Assert.notNull(context, \"ApplicationContext must not be null\");\n\n        this.contextMap.put(key, context);\n        MergedContextConfiguration child = key;\n        MergedContextConfiguration parent = child.getParent();\n        while (parent != null) {\n            Set<MergedContextConfiguration> list = this.hierarchyMap.computeIfAbsent(parent, k -> new HashSet<>());\n            list.add(child);\n            child = parent;\n            parent = child.getParent();\n        }\n    }\n}\n```\n\nContextCaching이 어떻게 동작하는지 이해했다면, 정말로 CacheKey가 달라졌을때 ApplicationContext가 재사용되지 않는지 확인해보자.\n\n## 예제 코드\n\n위치 좌표 정보를 외부 API에서 조회하는 예제를 통해 살펴보자. 먼저 Bean으로 등록할 객체 하나와 위치 API 클라이언트 인터페이스를 정의한다.\n\n```java\n@Service\npublic class TransportService {\n\n    private final String instanceId;\n\n    public TransportService() {\n        this.instanceId = java.util.UUID.randomUUID().toString();\n    }\n\n    public String getInstanceId() {\n        return instanceId;\n    }\n}\n```\n\n```java\npublic interface LocationApiClient {\n    \n    // 주소로 위치 좌표를 조회한다\n    LocationCoordinate getCoordinatesByAddress(String address);\n\n\n    // 현재 API 클라이언트의 인스턴스 ID를 반환한다\n    String getInstanceId();\n}\n```\n\n다음으로 실제 API를 호출하는 구현체를 작성하였다.\n\n```java\n@Service\npublic class KakaoLocationApiClient implements LocationApiClient {\n\n    private final RestTemplate restTemplate;\n    private final String apiKey;\n    private final String instanceId;\n\n    public KakaoLocationApiClient(@Value(\"${kakao.api.key:SAMPLE_API_KEY}\") String apiKey) {\n        this.restTemplate = new RestTemplate();\n        this.apiKey = apiKey;\n        this.instanceId = UUID.randomUUID().toString();\n    }\n\n    @Override\n    public LocationCoordinate getCoordinatesByAddress(String address) {\n        // 실제 API 호출 코드\n        String url = \"https://dapi.kakao.com/v2/local/search/address.json?query=\" + address;\n        \n        HttpHeaders headers = new HttpHeaders();\n        headers.set(\"Authorization\", \"KakaoAK \" + apiKey);\n        \n        HttpEntity<String> entity = new HttpEntity<>(headers);\n        \n        try {\n            ResponseEntity<Map> response = restTemplate.exchange(url, HttpMethod.GET, entity, Map.class);\n            // 응답 처리 로직...\n            return parseResponse(response.getBody(), address);\n        } catch (Exception e) {\n            throw new RuntimeException(\"위치 정보 조회 실패: \" + e.getMessage(), e);\n        }\n    }\n\n    @Override\n    public String getInstanceId() {\n        return instanceId;\n    }\n}\n```\n\n이제 ApplicationContext의 재사용 여부를 검증하기 위한 테스트를 작성해 보도록 하자.\n\n- 첫 번째 테스트: 기본 컨텍스트 로드\n- 두 번째 테스트: 동일한 설정으로 컨텍스트 재사용 확인\n- 세 번째 테스트: MockBean 사용으로 컨텍스트 재생성 확인\n\n```java\npublic class ContextCachingVerificationTest {\n\n    Logger log = LoggerFactory.getLogger(ContextCachingVerificationTest.class);\n\n    @Nested\n    @SpringBootTest\n    class FirstTest {\n\n        @Autowired\n        ApplicationContext context;\n        \n        @Autowired\n        TransportService transportService;\n\n        @Test\n        void saveFirstContextInfo() {\n            assertThat(context).isNotNull();\n            assertThat(transportService).isNotNull();\n\n            // 첫 번째 컨텍스트 정보 출력\n            log.info(\"FirstTest - Context hash: {}\", System.identityHashCode(context));\n            log.info(\"FirstTest - TransportService instance ID: {}\", transportService.getInstanceId());\n        }\n    }\n\n    @Nested\n    @SpringBootTest\n    class SecondTest {\n\n        @Autowired\n        ApplicationContext context;\n        \n        @Autowired\n        TransportService transportService;\n\n        @Test\n        void verifyContextReuse() {\n            assertThat(context).isNotNull();\n            assertThat(transportService).isNotNull();\n\n            // 두 번째 컨텍스트 정보 출력\n            log.info(\"SecondTest - Context hash: {}\", System.identityHashCode(context));\n            log.info(\"SecondTest - TransportService instance ID: {}\", transportService.getInstanceId());\n        }\n    }\n\n    @Nested\n    @SpringBootTest\n    class ThirdTestWithMockBean {\n\n        @Autowired\n        ApplicationContext context;\n        \n        @Autowired\n        TransportService transportService;\n        \n        @MockBean\n        LocationApiClient locationApiClient;\n\n        @Test\n        void verifyNewContextCreation() {\n            assertThat(context).isNotNull();\n            assertThat(transportService).isNotNull();\n            assertThat(locationApiClient).isNotNull();\n\n            log.info(\"MockTest - Context hash: {}\", System.identityHashCode(context));\n            log.info(\"MockTest - TransportService instance ID: {}\", transportService.getInstanceId());\n        }\n    }\n}\n```\n\n첫 번째 테스트와 두 번째 테스트는 동일한 설정으로 컨텍스트를 재사용하기 때문에 ApplicationContext가 재사용되는 것을 기대할 수 있다.\n만약 ApplicationContext가 재사용됐다면, 첫 번째 테스트와 두 번째 테스트의 ApplicationContext 해시코드가 동일할 것이고 TransportService의 인스턴스 ID도 동일할 것이다.\n\n세 번째 테스트는 @MockBean을 사용했기 때문에 ContextCahche에서 동일한 키를 찾지 못하여 ApplicationContext가 재사용되지 않고 새로 생성될 것이다.\n즉, 첫 번째, 두 번째 테스트와는 다른 ApplicationContext가 생성될 것이고, TransportService의 인스턴스 ID도 다를 것이다.\n\n### 테스트 실행 결과\n\n![](https://i.imgur.com/Uxk21uj.png)\n\n![](https://i.imgur.com/x0gCXng.png)\n\n\n예상과 같이 첫 번째 테스트와 두 번째 테스트는 동일한 ApplicationContext를 재사용하고, 세 번째 테스트는 @MockBean을 사용하여 새로운 ApplicationContext가 생성되는 것을 확인할 수 있었다.\n\n## 테스트 대역을 사용하면서 ApplicationContext를 재사용하는 방법\n\n어떻게 하면 테스트 대역을 사용하여 실제 API를 호출하지 않으면서도 ApplicationContext를 재사용 하여 테스트 실행 속도를 개선할 수 있을까?\n\n### Stub으로 @MockBean 대체하기\n\n인터페이스를 구현하거나 테스트 대역 클래스를 상속받아 스텁 객체를 만들어 @MockBean을 대체할 수 있다. 이 방법은 외부 API와 같은 의존성을 테스트할 때 특히 유용하다.\n\n테스트에서 사용할 스텁 구현체를 아래와 같이 정의한다.\n\n```java\n@Service\n@Profile(\"test\")\npublic class StubLocationApiClient implements LocationApiClient {\n\n    private final String instanceId = \"stub-instance-id\";\n\n    @Override\n    public LocationCoordinate getCoordinatesByAddress(String address) {\n        // 테스트용 고정 좌표 반환\n        return new LocationCoordinate(37.5665, 126.9780, \"테스트 주소: \" + address);\n    }\n\n    @Override\n    public String getInstanceId() {\n        return instanceId;\n    }\n}\n```\n\n이 스텁 구현체는 실제 API를 호출하지 않고 테스트에 필요한 고정된 값을 반환한다. 이를 통해 테스트 실행 속도를 높이고 외부 의존성 없이 안정적인 테스트를 수행할 수 있다.\n\n테스트 환경에서만 스텁 구현체를 사용하도록 @Profile을 설정하였다. `src/test/resources/application-test.yml` 파일을 생성하여 프로파일을 설정해주자.\n\n환경변수를 주입할 수 있는 곳이 여러군데 있긴 하지만 `build.gradle`에 아래와 같이 설정해주면 편리하게 환경변수를 주입할 수 있다.\n\n```groovy\ntasks.named('test') {\n    useJUnitPlatform()\n    systemProperty(\"spring.profiles.active\", \"test\")\n}\n```\n\n이제 테스트에서 이 스텁 구현체를 사용하도록 설정한 다음 ApplicationContext를 재사용하는지 확인해보자.\n\n```java\npublic class ContextCachingVerificationTest {\n\n    Logger log = LoggerFactory.getLogger(ContextCachingVerificationTest.class);\n\n    @Nested\n    @SpringBootTest\n    class FirstTest {\n\n        @Autowired\n        ApplicationContext context;\n        \n        @Autowired\n        TransportService transportService;\n\n        @Test\n        void saveFirstContextInfo() {\n            assertThat(context).isNotNull();\n            assertThat(transportService).isNotNull();\n\n            // 첫 번째 컨텍스트 정보 출력\n            log.info(\"FirstTest - Context hash: {}\", System.identityHashCode(context));\n            log.info(\"FirstTest - TransportService instance ID: {}\", transportService.getInstanceId());\n        }\n    }\n\n    @Nested\n    @SpringBootTest\n    class SecondTest {\n\n        @Autowired\n        ApplicationContext context;\n        \n        @Autowired\n        TransportService transportService;\n\n        @Test\n        void verifyContextReuse() {\n            assertThat(context).isNotNull();\n            assertThat(transportService).isNotNull();\n\n            // 두 번째 컨텍스트 정보 출력\n            log.info(\"SecondTest - Context hash: {}\", System.identityHashCode(context));\n            log.info(\"SecondTest - TransportService instance ID: {}\", transportService.getInstanceId());\n        }\n    }\n\n    @Nested\n    @SpringBootTest\n    class ThirdTestWithMockBean {\n\n        @Autowired\n        ApplicationContext context;\n        \n        @Autowired\n        TransportService transportService;\n        \n        @Autowired\n        LocationApiClient stubLocationApiClient;\n\n        @Test\n        void verifyNewContextCreation() {\n            assertThat(context).isNotNull();\n            assertThat(transportService).isNotNull();\n            assertThat(stubLocationApiClient).isNotNull();\n\n            log.info(\"MockTest - Context hash: {}\", System.identityHashCode(context));\n            log.info(\"MockTest - TransportService instance ID: {}\", transportService.getInstanceId());\n            log.info(\"MockTest - LocationApiClient instance ID: {}\", stubLocationApiClient.getInstanceId());\n        }\n    }\n}\n```\n\n### 테스트 실행 결과\n\n![](https://i.imgur.com/LKE56mb.png)\n\n테스트 실행 결과를 확인해보면, 스텁을 사용한 테스트가 ApplicationContext를 재사용하는 것을 확인할 수 있다.\n\n### 마무리\n\n@SpringBootTest를 사용한 테스트에서 @MockBean과 @SpyBean을 남용하면 ApplicationContext가 재사용되지 않아 테스트 실행 속도가 느려질 수 있으며,\n메모리 사용량이 늘어나서 OOM이 발생할 수 있다.\n\n물론 테스트가 많지 않다면 문제가 되지 않겠지만, 테스트가 많아질 경우 Stub을 사용하여 @MockBean과 @SpyBean을 대체하는 방안을 고려해보자.\n\n### 참고 자료\n- https://github.com/spring-projects/spring-boot/issues/10015\n"},"__N_SSG":true}