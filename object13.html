<!DOCTYPE html><html><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><link rel="apple-touch-icon" sizes="180x180" href="https://i.imgur.com/2nHGFTv.png"/><link rel="icon" type="image/png" sizes="32x32" href="https://i.imgur.com/2nHGFTv.png"/><link rel="icon" type="image/png" sizes="16x16" href="https://i.imgur.com/2nHGFTv.png"/><link rel="manifest" href="/site.webmanifest"/><link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5"/><meta name="msapplication-TileColor" content="#da532c"/><meta name="theme-color" content="#ffffff"/><title>[오브젝트] 13장 - 서브클래싱과 서브타이핑</title><meta name="title" content="[오브젝트] 13장 - 서브클래싱과 서브타이핑"/><meta name="description" content=""/><meta name="keywords" content=""/><meta name="robots" content="index, follow"/><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><meta name="language" content="Korean"/><meta name="author" content="Sanha Ko"/><meta property="og:title" content="[오브젝트] 13장 - 서브클래싱과 서브타이핑"/><meta property="og:url" content="https://headf1rst.github.io/TIL/object13"/><meta property="og:type" content="blog"/><meta property="og:image" content="https://wikibook.co.kr/images/cover/m/9791158391409.png"/><meta property="og:description"/><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","headline":"[오브젝트] 13장 - 서브클래싱과 서브타이핑","datePublished":"2022-11-29 10:00","dateModified":"2022-11-29 10:00","author":{"@type":"Person","name":"Sanha Ko"},"description":"","image":"https://wikibook.co.kr/images/cover/m/9791158391409.png","url":"https://headf1rst.github.io/TIL/object13","keywords":"object","publisher":{"@type":"Organization","name":"headF1rst","logo":{"@type":"ImageObject","url":"https://headf1rst.github.io/TIL/favicon.ico"}},"mainEntityOfPage":{"@type":"WebPage","@id":"https://headf1rst.github.io/TIL/object13"}}</script><meta name="next-head-count" content="23"/><link rel="preload" href="/TIL/_next/static/css/754b961274c075df.css" as="style"/><link rel="stylesheet" href="/TIL/_next/static/css/754b961274c075df.css" data-n-g=""/><link rel="preload" href="/TIL/_next/static/css/38994dd0aed51f22.css" as="style"/><link rel="stylesheet" href="/TIL/_next/static/css/38994dd0aed51f22.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/TIL/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/TIL/_next/static/chunks/webpack-ac557983bcc4c022.js" defer=""></script><script src="/TIL/_next/static/chunks/framework-2c79e2a64abdb08b.js" defer=""></script><script src="/TIL/_next/static/chunks/main-dc8c1543918dad35.js" defer=""></script><script src="/TIL/_next/static/chunks/pages/_app-421e211a78340d83.js" defer=""></script><script src="/TIL/_next/static/chunks/202-7f08bae5ecc79443.js" defer=""></script><script src="/TIL/_next/static/chunks/pages/%5Bid%5D-a17d958fe22e8c91.js" defer=""></script><script src="/TIL/_next/static/rHHwQgn4XzsFFzcKqsKPc/_buildManifest.js" defer=""></script><script src="/TIL/_next/static/rHHwQgn4XzsFFzcKqsKPc/_ssgManifest.js" defer=""></script></head><body><div id="__next"><nav class="flex bg-white sticky top-0 left-0 z-50 justify-between items-center border-b-2 border-gray-100 py-3 md:justify-start md:space-x-10 px-10 sm:px-5 dark:bg-[#0d1117] dark:text-[#c9d1d9] dark:border-gray-600"><div class="flex justify-start"><a href="/TIL"><div class="flex items-center gap-2 cursor-pointer"><img src="https://i.imgur.com/2nHGFTv.png" width="40" height="40" alt="블로그 아이콘"/><h1 class="text-lg ">산하개발실록</h1></div></a></div><div class="flex justify-between gap-10 sm:hidden"><a href="/TIL"><button class="font-light hover:text-indigo-300 text-base">Home</button></a><a href="/TIL/category"><button class="font-light hover:text-indigo-300 text-base">Category</button></a><a href="https://plain-composer-c65.notion.site/29c7640fdf054059b6ea28ed61189bfb" target="_blank" rel="noreferrer" class="hover:text-indigo-300 text-base font-light flex gap-1">About<span class="flex justify-center" style="align-items:center"><svg stroke="currentColor" fill="currentColor" stroke-width="0" viewBox="0 0 24 24" height="1em" width="1em" xmlns="http://www.w3.org/2000/svg"><path d="m13 3 3.293 3.293-7 7 1.414 1.414 7-7L21 11V3z"></path><path d="M19 19H5V5h7l-2-2H5c-1.103 0-2 .897-2 2v14c0 1.103.897 2 2 2h14c1.103 0 2-.897 2-2v-5l-2-2v7z"></path></svg></span></a></div><svg stroke="currentColor" fill="currentColor" stroke-width="0" viewBox="0 0 512 512" class="lg:hidden" height="25" width="25" xmlns="http://www.w3.org/2000/svg"><path d="M32 96v64h448V96H32zm0 128v64h448v-64H32zm0 128v64h448v-64H32z"></path></svg></nav><main class="dark:bg-[#0d1117] h-screen pb-10"><div class="flex flex-col w-3/5 sm:w-5/6 m-auto pt-20 pb-20 gap-10 dark:bg-[#0d1117] dark:text-[#c9d1d9]"><ul id="scroll-spy" class="sm:hidden p-10 fixed top-50 right-0 h-full w-1/5 text-gray-500 dark:text-[#c9d1d9]"></ul><div class="text-5xl font-bold">[오브젝트] 13장 - 서브클래싱과 서브타이핑</div><div class="flex flex-col gap-2"><div class="text-base text-gray-600 dark:text-gray-300">2022-11-29 10:00</div><div class="flex flex-wrap gap-2 dark:text-black sm:m-0"><span class="p-1 pl-3 pr-3 rounded-md bg-indigo-100 hover:bg-indigo-200 cursor-pointer transition ease-in-out duration-200 text-sm">object</span></div></div><div class="markdown-body" style="font-size:17px"><p>상속이 사용되는 두 가지 용도</p>
<ul>
<li>
<p>타입 계층을 구현하는 것</p>
<ul>
<li>부모 클래스<!-- -->
<ul>
<li>일반적인 개념을 구현</li>
<li>부모 클래스는 자식 클래스의 일반화</li>
</ul>
</li>
<li>자식 클래스<!-- -->
<ul>
<li>특수한 개념을 구현</li>
<li>자식 클래스는 부모 클래스의 특수화</li>
</ul>
</li>
</ul>
</li>
<li>
<p>코드 재사용</p>
<ul>
<li>부모 클래스의 코드를 재사용하는 것이 가능</li>
<li>단, 부모, 자식 클래스가 강하게 결합되어 변경하기 어려운 코드가 탄생</li>
</ul>
</li>
<li>
<p>상속의 사용 이유는 <code node="[object Object]">타입 계층을 구현하는 것</code>이어야 한다.</p>
<ul>
<li>객체의 행동을 기반으로 타입 계층을 구성해야한다.</li>
</ul>
</li>
</ul>
<h2>1. 올바른 타입 계층을 구성하는 원칙</h2>
<h3>개념 관점의 타입</h3>
<ul>
<li>
<p>타입</p>
<ul>
<li>공통의 특징을 공유하는  대상들의 분류</li>
<li>사물을 분류하기 위한 틀</li>
<li>ex) <code node="[object Object]">자바, 루비, 자바스크립트</code> - 프로그래밍 언어 타입</li>
</ul>
</li>
<li>
<p>타입의 인스턴스 (객체)</p>
<ul>
<li>타입으로 분류되는 대상</li>
<li>ex) <code node="[object Object]">자바</code> - 프로그래밍 언어의 인스턴스</li>
</ul>
</li>
<li>
<p>타입의 구성 요소</p>
<ul>
<li>심볼: 타입의 이름</li>
<li>내연: 타임의 정의. 타입에 속한 객체들이 가지는 공통적인 속성, 행동</li>
<li>외연: 타입에 속하는 객체들의 집합</li>
</ul>
</li>
</ul>
<h3>프로그래밍 언어 관점의 타입</h3>
<p>하드웨어는 데이터를 0과 1로 구성된 일련의 비트 조합으로 취급.
비트 자체에는 타입이라는 개념이 존재하지 않기 때문에 비트에 담긴 데이터를 문자열로 다룰지, 정수로 다룰지는 데이터를 사용하는 어플리케이션에 의해 결정된다.</p>
<ul>
<li>타입<!-- -->
<ul>
<li>동일한 오퍼레이션을 적용할 수 있는 인스턴스들의 집합</li>
<li>비트 묶음에 의미를 부여하기 위해 정의된 제약과 규칙</li>
</ul>
</li>
<li>타입의 두 가지 목적<!-- -->
<ul>
<li>객체의 타입에 따라 적용 가능한 연산자의 종류를 제한하여 프로그래머의 실수를 방지</li>
<li>타입에 수행되는 오퍼레이션에 대해 미리 약속된 문맥을 제공<!-- -->
<ul>
<li>a와 b에 부여된 타입이 <code node="[object Object]">+</code> 연산자의 문맥을 정의.</li>
<li>new 연산자는 타입에 정의된 만큼 저장 공간을 할당하고 객체를 초기화하기 위해 타입 생성자를 자동으로 호출</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3>객체지향 패러다임 관점의 타입</h3>
<ul>
<li>타입<!-- -->
<ul>
<li>객체의 퍼블릭 인터페이스를 정의하는 것<!-- -->
<ul>
<li>퍼블릭 인터페이스<!-- -->
<ul>
<li>객체가 수신할 수 있는 메시지의 집합</li>
</ul>
</li>
</ul>
</li>
<li>동일한 퍼블릭 인터페이스를 가지는 객체들은 동일한 타입<!-- -->
<ul>
<li>객체가 수신할 수 있는 메시지를 기준으로 타입을 분류</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2>2. 타입 계층</h2>
<p>타입 계층은 포함 관계로 연결되어있다.</p>
<p>퍼블릭 인터페이스 관점에서의 슈퍼타입과 서브타입</p>
<ul>
<li>슈퍼타입<!-- -->
<ul>
<li>서브타입이 정의한 퍼블릭 인터페이스를 인반화시켜 상대적으로 범용적이고 넓은 의미로 정의한 것.</li>
</ul>
</li>
<li>서브타입<!-- -->
<ul>
<li>슈퍼타입이 정의한 퍼블릭 인터페이스를 특수화시켜 상대적으로 구체적이고 좁은 의미로 정의한 것.</li>
<li>서브타입의 인스턴스는 슈퍼타입의 인스턴스로 간주될 수 있다.</li>
</ul>
</li>
</ul>
<h2>3. 서브클래싱과 서브타이핑</h2>
<p>타입 계층을 구현할 때 지켜야 하는 제약사항</p>
<h3>언제 상속을 사용해야 하는가?</h3>
<p>상속의 올바른 용도는 <code node="[object Object]">타입 계층</code>을 구현하는 것.
아래 두 질문에 모두 &#x27;예&#x27;라고 답할 수 있을때만 상속을 사용.</p>
<ul>
<li>상속 관계가 is-a 관계를 모델링하는가?<!-- -->
<ul>
<li>[자식 클래스]는 [부모 클래스]다 라고 말해도 이상하지 않는 경우</li>
<li>단, 어휘적 정의가 아니라 기대되는 행동에 따라 타입 계층을 구성해야 한다.</li>
</ul>
</li>
<li>클라이언트 입장에서 부모 클래스의 타입으로 자식 클래스를 사용해도 무방한가? ⭐️<!-- -->
<ul>
<li>상속 계층을 사용하는 클라이언트의 입장에서 부모 클래스와 자식 클래스의 차이점을 몰라야 한다. - <code node="[object Object]">자식 클래스와 부모 클래스의 행동 호환성</code></li>
</ul>
</li>
</ul>
<p><code node="[object Object]">팽귄과 새</code>는 is-a 관계로 묶을 수 있지만 새와 팽귄의 서로 다른 행동 방식 (날 수 있는지 여부)은 동일한 타입 계층으로 묶어서는 안된다고 경고한다.</p>
<h3>행동 호환성</h3>
<ul>
<li>두 타입 사이에 행동이 호환될 경우에만 타입 계층으로 묶어야 한다.</li>
<li>행동의 호환 여부를 판단하는 기준은 클라이언트의 관점<!-- -->
<ul>
<li>클라이언트가 두 타입이 동일하게 행동할 것이라고 기대하면 두 타입을 타입 계층으로 묶을 수 있다.</li>
</ul>
</li>
</ul>
<h3>클라이언트의 기대에 따라 계층을 분리하라.</h3>
<p>행동 호환성을 만족시키지 않는 상속 계층을 유지하기란 쉽지 않다.
클라이언트의 기대에 맞게 상속 계층을 분리하라.</p>
<ul>
<li>인터페이스는 클라이언트가 기대하는 바에 따라 분리돼야 한다.<!-- -->
<ul>
<li>인터페이스 분리 원칙 (ISP)</li>
</ul>
</li>
<li>두 클래스 사이에 행동이 호환되지 않는다면 올바른 타입 계층이 아니므로 상속을 사용해서는 안된다.</li>
</ul>
<h3>서브클래싱과 서브타이핑</h3>
<ul>
<li>서브클래싱<!-- -->
<ul>
<li>코드 재사용 목적으로 상속을 사용하는 경우</li>
<li>자식 클래스와 부모 클래스의 행동이 호환되지 않는다.<!-- -->
<ul>
<li>자식 클래스의 인스턴스가 부모 클래스의 인스턴스를 대체할 수 없다.</li>
</ul>
</li>
</ul>
</li>
<li>서브타이핑<!-- -->
<ul>
<li>타입 계층 구성을 위해 상속을 사용하는 경우</li>
<li>자식 클래스와 부모 클래스의 행동이 호환된다.<!-- -->
<ul>
<li>자식 클래스의 인스턴스가 부모 클래스의 인스턴스를 대체할 수 있다. (LSP)</li>
<li>부모 클래스는 자식 클래스의 <code node="[object Object]">슈퍼타입</code>이 된다.</li>
<li>자식 클래스는 부모 클래스의 <code node="[object Object]">서브타입</code>이 된다.</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2>4. 리스코프 치환 원칙</h2>
<p>상속 관계로 연결한 두 클래스가 서브타이핑 관계를 만족시키며 서브타입은 그것의 기반 타입에 대해 대체 가능해야 한다.</p>
<h3>리스코프 치환 원칙을 위반하는 is-a 관계 (정사각형, 직사각형)</h3>
<pre><div node="[object Object]" style="display:block;overflow-x:auto;padding:0.5em;color:#383a42;background:#fafafa"><code class="language-java" style="white-space:pre"><span style="color:#a626a4">public</span><span> </span><span class="hljs-class" style="color:#a626a4">class</span><span class="hljs-class"> </span><span class="hljs-class" style="color:#4078f2">Rectangle</span><span class="hljs-class"> </span><span>{
</span>
<span>	</span><span style="color:#a626a4">private</span><span> </span><span style="color:#a626a4">int</span><span> x, y, width, height;
</span>
<span>	</span><span class="hljs-function" style="color:#a626a4">public</span><span class="hljs-function"> </span><span class="hljs-function" style="color:#4078f2">Rectangle</span><span class="hljs-function hljs-params">(</span><span class="hljs-function hljs-params" style="color:#a626a4">int</span><span class="hljs-function hljs-params"> x, </span><span class="hljs-function hljs-params" style="color:#a626a4">int</span><span class="hljs-function hljs-params"> y, </span><span class="hljs-function hljs-params" style="color:#a626a4">int</span><span class="hljs-function hljs-params"> width, </span><span class="hljs-function hljs-params" style="color:#a626a4">int</span><span class="hljs-function hljs-params"> height)</span><span class="hljs-function"> </span><span>{
</span><span>		</span><span style="color:#a0a1a7;font-style:italic">// 생략</span><span>
</span>	}
<!-- -->
<span>	</span><span class="hljs-function" style="color:#a626a4">public</span><span class="hljs-function"> </span><span class="hljs-function" style="color:#a626a4">void</span><span class="hljs-function"> </span><span class="hljs-function" style="color:#4078f2">setWidth</span><span class="hljs-function hljs-params">(</span><span class="hljs-function hljs-params" style="color:#a626a4">int</span><span class="hljs-function hljs-params"> width)</span><span class="hljs-function"> </span><span>{
</span><span>		</span><span style="color:#a626a4">this</span><span>.width = width;
</span>	}
<!-- -->
<span>	</span><span class="hljs-function" style="color:#a626a4">public</span><span class="hljs-function"> </span><span class="hljs-function" style="color:#a626a4">void</span><span class="hljs-function"> </span><span class="hljs-function" style="color:#4078f2">setHeigth</span><span class="hljs-function hljs-params">(</span><span class="hljs-function hljs-params" style="color:#a626a4">int</span><span class="hljs-function hljs-params"> height)</span><span class="hljs-function"> </span><span>{
</span><span>		</span><span style="color:#a626a4">this</span><span>.height = height;
</span>	}
<!-- -->}</code></div></pre>
<pre><div node="[object Object]" style="display:block;overflow-x:auto;padding:0.5em;color:#383a42;background:#fafafa"><code class="language-java" style="white-space:pre"><span style="color:#a626a4">public</span><span> </span><span class="hljs-class" style="color:#a626a4">class</span><span class="hljs-class"> </span><span class="hljs-class" style="color:#4078f2">Square</span><span class="hljs-class"> </span><span class="hljs-class" style="color:#a626a4">extends</span><span class="hljs-class"> </span><span class="hljs-class" style="color:#4078f2">Rectangle</span><span class="hljs-class"> </span><span>{
</span>
<span>	</span><span class="hljs-function" style="color:#a626a4">public</span><span class="hljs-function"> </span><span class="hljs-function" style="color:#4078f2">Square</span><span class="hljs-function hljs-params">(</span><span class="hljs-function hljs-params" style="color:#a626a4">int</span><span class="hljs-function hljs-params"> x, </span><span class="hljs-function hljs-params" style="color:#a626a4">int</span><span class="hljs-function hljs-params"> y, </span><span class="hljs-function hljs-params" style="color:#a626a4">int</span><span class="hljs-function hljs-params"> size)</span><span class="hljs-function"> </span><span>{
</span><span>		</span><span style="color:#a626a4">super</span><span>(x, y, size, size);
</span>	}
<!-- -->
<span>	</span><span style="color:#4078f2">@Override</span><span>
</span><span>	</span><span class="hljs-function" style="color:#a626a4">public</span><span class="hljs-function"> </span><span class="hljs-function" style="color:#a626a4">void</span><span class="hljs-function"> </span><span class="hljs-function" style="color:#4078f2">setWidth</span><span class="hljs-function hljs-params">(</span><span class="hljs-function hljs-params" style="color:#a626a4">int</span><span class="hljs-function hljs-params"> width)</span><span class="hljs-function"> </span><span>{
</span><span>		</span><span style="color:#a626a4">super</span><span>.setWidth(width);
</span><span>		</span><span style="color:#a626a4">super</span><span>.setHeight(width);
</span>	}
<!-- -->
<span>	</span><span style="color:#4078f2">@Override</span><span>
</span><span>	</span><span class="hljs-function" style="color:#a626a4">public</span><span class="hljs-function"> </span><span class="hljs-function" style="color:#a626a4">void</span><span class="hljs-function"> </span><span class="hljs-function" style="color:#4078f2">setHeight</span><span class="hljs-function hljs-params">(</span><span class="hljs-function hljs-params" style="color:#a626a4">int</span><span class="hljs-function hljs-params"> height)</span><span class="hljs-function"> </span><span>{
</span><span>		</span><span style="color:#a626a4">super</span><span>.setWidth(height);
</span><span>		</span><span style="color:#a626a4">super</span><span>.setHeight(height);
</span>	}
<!-- -->}</code></div></pre>
<pre><div node="[object Object]" style="display:block;overflow-x:auto;padding:0.5em;color:#383a42;background:#fafafa"><code class="language-java" style="white-space:pre"><span class="hljs-function" style="color:#a626a4">public</span><span class="hljs-function"> </span><span class="hljs-function" style="color:#a626a4">void</span><span class="hljs-function"> </span><span class="hljs-function" style="color:#4078f2">resize</span><span class="hljs-function hljs-params">(Rectangle rectangle, </span><span class="hljs-function hljs-params" style="color:#a626a4">int</span><span class="hljs-function hljs-params"> width, </span><span class="hljs-function hljs-params" style="color:#a626a4">int</span><span class="hljs-function hljs-params"> height)</span><span class="hljs-function"> </span><span>{
</span>	rectangle.setWidth(width);
<!-- -->	rectangle.setHeight(height);
<span>	</span><span style="color:#a626a4">assert</span><span> rectangle.getWidth() == width &amp;&amp; rectangle.getHeight() == height;
</span>}</code></div></pre>
<p>클라이언트가 <code node="[object Object]">resize()</code> 메서드를 사용한다고 할때,</p>
<ul>
<li>
<p><code node="[object Object]">Rectangle</code>을 사용하는 클라이언트는</p>
<ul>
<li>Rectangle의 너비와 높이가 다를 수 있다는 가정하에 코드를 개발.</li>
<li>하지만 <code node="[object Object]">Square</code> 는 너비와 높이가 항상 같다.</li>
<li>Ractangle을 Square로 대체할 경우 Rectangle에 세워진 가정을 위반할 확률이 높다.</li>
</ul>
</li>
<li>
<p>is-a 관계의 문장 앞에 <code node="[object Object]">&quot;클라이언트 입장에서&quot;</code>라는 말이 빠져 있다고 생각하라.</p>
</li>
<li>
<p>클라이언트 입장에서 퍼블릭 인터페이스의 행동 방식이 변경되지 않는다면 클라이언트의 코드를 변경하지 않고도 새로운 자식 클래스와 협력할 수 있게 된다.</p>
</li>
</ul>
<h3>느낀점</h3>
<p>면접 단골 예상 질문이라며 인터페이스와 추상 클래스의 차이점에 대한 질문을 본적이 있습니다. 자바8, 9로 넘어오면서 부터는 인터페이스에서도 디폴트 메서드를 정의하거나 private 메서드를 정의하는것이 가능해 졌습니다.</p>
<p>이처럼 인터페이스가 점점 추상 클래스의 역할까지 담당해 나가고 있고 인프런 강의 영상에서도 점점 추상클래스를 사용하지 않고 있다는 말을 들은적이 있습니다. 때문에 문득 그럼에도 추상클래스가 필요한 이유가 있을까?라는 의문을 갖고 찾아보게 되었습니다.</p>
<ul>
<li>인터페이스에선 <code node="[object Object]">final</code> 메서드를 정의할 수 없다.<!-- -->
<ul>
<li>서브클래스에서 어떠한 메서드가 재정의 (오버라이드)되는 것을 의도적으로 막기 위해서는 final 메서드가 필요하다</li>
</ul>
</li>
<li>인터페이스는 상태를 갖지 못한다.</li>
<li>커뮤니케이션 가치<!-- -->
<ul>
<li>인터페이스는 구현해야하는 존재</li>
<li>구현될 필요가 없는 인터페이스를 의도하고 작성하였지만 누군가는 인터페이스를 보고 구현해야 할 존재로 바라볼 수 있다. 즉, 사람들의 예상과 다른 코드를 작성하여 오해를 불러 일으키는 코드를 작성하게 된다.</li>
</ul>
</li>
<li>생성자를 선언하지 못한다.</li>
</ul>
<p>https://www.quora.com/Do-we-need-abstract-classes-anymore-when-we-have-Java-8s-interfaces-with-default-and-static-methods</p></div><section></section></div></main></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"postData":{"id":"object13","title":"[오브젝트] 13장 - 서브클래싱과 서브타이핑","category":"object","thumbnail":"https://wikibook.co.kr/images/cover/m/9791158391409.png","tags":"object","date":"2022-11-29 10:00","preview":"\n상속이 사용되는 두 가지 용도\n\n- 타입 계층을 구현하는 것\n    - 부모 클래스\n        - 일반적인 개념을 구현\n        - 부모 클래스는 자식 클래스의 일반화\n    - 자식 클래스\n        - 특수한 개념을 구현\n      "},"detail":"\n상속이 사용되는 두 가지 용도\n\n- 타입 계층을 구현하는 것\n    - 부모 클래스\n        - 일반적인 개념을 구현\n        - 부모 클래스는 자식 클래스의 일반화\n    - 자식 클래스\n        - 특수한 개념을 구현\n        - 자식 클래스는 부모 클래스의 특수화\n- 코드 재사용\n    - 부모 클래스의 코드를 재사용하는 것이 가능\n    - 단, 부모, 자식 클래스가 강하게 결합되어 변경하기 어려운 코드가 탄생\n\n- 상속의 사용 이유는 `타입 계층을 구현하는 것`이어야 한다.\n    - 객체의 행동을 기반으로 타입 계층을 구성해야한다.\n\n## 1. 올바른 타입 계층을 구성하는 원칙\n\n### 개념 관점의 타입\n\n- 타입\n    - 공통의 특징을 공유하는  대상들의 분류\n    - 사물을 분류하기 위한 틀\n    - ex) `자바, 루비, 자바스크립트` - 프로그래밍 언어 타입\n- 타입의 인스턴스 (객체)\n    - 타입으로 분류되는 대상\n    - ex) `자바` - 프로그래밍 언어의 인스턴스\n\n- 타입의 구성 요소\n    - 심볼: 타입의 이름\n    - 내연: 타임의 정의. 타입에 속한 객체들이 가지는 공통적인 속성, 행동\n    - 외연: 타입에 속하는 객체들의 집합\n\n### 프로그래밍 언어 관점의 타입\n\n하드웨어는 데이터를 0과 1로 구성된 일련의 비트 조합으로 취급.\n비트 자체에는 타입이라는 개념이 존재하지 않기 때문에 비트에 담긴 데이터를 문자열로 다룰지, 정수로 다룰지는 데이터를 사용하는 어플리케이션에 의해 결정된다.\n\n- 타입\n    - 동일한 오퍼레이션을 적용할 수 있는 인스턴스들의 집합\n    - 비트 묶음에 의미를 부여하기 위해 정의된 제약과 규칙\n- 타입의 두 가지 목적\n    - 객체의 타입에 따라 적용 가능한 연산자의 종류를 제한하여 프로그래머의 실수를 방지\n    - 타입에 수행되는 오퍼레이션에 대해 미리 약속된 문맥을 제공\n        - a와 b에 부여된 타입이 `+` 연산자의 문맥을 정의.\n        - new 연산자는 타입에 정의된 만큼 저장 공간을 할당하고 객체를 초기화하기 위해 타입 생성자를 자동으로 호출\n\n### 객체지향 패러다임 관점의 타입\n\n- 타입\n    - 객체의 퍼블릭 인터페이스를 정의하는 것\n        - 퍼블릭 인터페이스\n            - 객체가 수신할 수 있는 메시지의 집합\n    - 동일한 퍼블릭 인터페이스를 가지는 객체들은 동일한 타입\n        - 객체가 수신할 수 있는 메시지를 기준으로 타입을 분류\n\n## 2. 타입 계층\n\n타입 계층은 포함 관계로 연결되어있다.\n\n퍼블릭 인터페이스 관점에서의 슈퍼타입과 서브타입\n\n- 슈퍼타입\n    - 서브타입이 정의한 퍼블릭 인터페이스를 인반화시켜 상대적으로 범용적이고 넓은 의미로 정의한 것.\n- 서브타입\n    - 슈퍼타입이 정의한 퍼블릭 인터페이스를 특수화시켜 상대적으로 구체적이고 좁은 의미로 정의한 것.\n    - 서브타입의 인스턴스는 슈퍼타입의 인스턴스로 간주될 수 있다.\n\n## 3. 서브클래싱과 서브타이핑\n\n타입 계층을 구현할 때 지켜야 하는 제약사항\n\n### 언제 상속을 사용해야 하는가?\n\n상속의 올바른 용도는 `타입 계층`을 구현하는 것.\n아래 두 질문에 모두 '예'라고 답할 수 있을때만 상속을 사용.\n\n- 상속 관계가 is-a 관계를 모델링하는가?\n    - [자식 클래스]는 [부모 클래스]다 라고 말해도 이상하지 않는 경우\n    - 단, 어휘적 정의가 아니라 기대되는 행동에 따라 타입 계층을 구성해야 한다.\n- 클라이언트 입장에서 부모 클래스의 타입으로 자식 클래스를 사용해도 무방한가? ⭐️\n    - 상속 계층을 사용하는 클라이언트의 입장에서 부모 클래스와 자식 클래스의 차이점을 몰라야 한다. - `자식 클래스와 부모 클래스의 행동 호환성`\n\n`팽귄과 새`는 is-a 관계로 묶을 수 있지만 새와 팽귄의 서로 다른 행동 방식 (날 수 있는지 여부)은 동일한 타입 계층으로 묶어서는 안된다고 경고한다.\n\n### 행동 호환성\n\n- 두 타입 사이에 행동이 호환될 경우에만 타입 계층으로 묶어야 한다.\n- 행동의 호환 여부를 판단하는 기준은 클라이언트의 관점\n    - 클라이언트가 두 타입이 동일하게 행동할 것이라고 기대하면 두 타입을 타입 계층으로 묶을 수 있다.\n\n### 클라이언트의 기대에 따라 계층을 분리하라.\n\n행동 호환성을 만족시키지 않는 상속 계층을 유지하기란 쉽지 않다.\n클라이언트의 기대에 맞게 상속 계층을 분리하라.\n\n- 인터페이스는 클라이언트가 기대하는 바에 따라 분리돼야 한다.\n    - 인터페이스 분리 원칙 (ISP)\n- 두 클래스 사이에 행동이 호환되지 않는다면 올바른 타입 계층이 아니므로 상속을 사용해서는 안된다.\n\n### 서브클래싱과 서브타이핑\n\n- 서브클래싱\n    - 코드 재사용 목적으로 상속을 사용하는 경우\n    - 자식 클래스와 부모 클래스의 행동이 호환되지 않는다.\n        - 자식 클래스의 인스턴스가 부모 클래스의 인스턴스를 대체할 수 없다.\n- 서브타이핑\n    - 타입 계층 구성을 위해 상속을 사용하는 경우\n    - 자식 클래스와 부모 클래스의 행동이 호환된다.\n        - 자식 클래스의 인스턴스가 부모 클래스의 인스턴스를 대체할 수 있다. (LSP)\n        - 부모 클래스는 자식 클래스의 `슈퍼타입`이 된다.\n        - 자식 클래스는 부모 클래스의 `서브타입`이 된다.\n\n## 4. 리스코프 치환 원칙\n\n상속 관계로 연결한 두 클래스가 서브타이핑 관계를 만족시키며 서브타입은 그것의 기반 타입에 대해 대체 가능해야 한다.\n\n### 리스코프 치환 원칙을 위반하는 is-a 관계 (정사각형, 직사각형)\n\n```java\npublic class Rectangle {\n\n\tprivate int x, y, width, height;\n\n\tpublic Rectangle(int x, int y, int width, int height) {\n\t\t// 생략\n\t}\n\n\tpublic void setWidth(int width) {\n\t\tthis.width = width;\n\t}\n\n\tpublic void setHeigth(int height) {\n\t\tthis.height = height;\n\t}\n}\n```\n\n```java\npublic class Square extends Rectangle {\n\n\tpublic Square(int x, int y, int size) {\n\t\tsuper(x, y, size, size);\n\t}\n\n\t@Override\n\tpublic void setWidth(int width) {\n\t\tsuper.setWidth(width);\n\t\tsuper.setHeight(width);\n\t}\n\n\t@Override\n\tpublic void setHeight(int height) {\n\t\tsuper.setWidth(height);\n\t\tsuper.setHeight(height);\n\t}\n}\n```\n\n```java\npublic void resize(Rectangle rectangle, int width, int height) {\n\trectangle.setWidth(width);\n\trectangle.setHeight(height);\n\tassert rectangle.getWidth() == width \u0026\u0026 rectangle.getHeight() == height;\n}\n```\n\n클라이언트가 `resize()` 메서드를 사용한다고 할때,\n\n- `Rectangle`을 사용하는 클라이언트는\n    - Rectangle의 너비와 높이가 다를 수 있다는 가정하에 코드를 개발.\n    - 하지만 `Square` 는 너비와 높이가 항상 같다.\n    - Ractangle을 Square로 대체할 경우 Rectangle에 세워진 가정을 위반할 확률이 높다.\n\n- is-a 관계의 문장 앞에 `\"클라이언트 입장에서\"`라는 말이 빠져 있다고 생각하라.\n- 클라이언트 입장에서 퍼블릭 인터페이스의 행동 방식이 변경되지 않는다면 클라이언트의 코드를 변경하지 않고도 새로운 자식 클래스와 협력할 수 있게 된다.\n\n### 느낀점\n\n면접 단골 예상 질문이라며 인터페이스와 추상 클래스의 차이점에 대한 질문을 본적이 있습니다. 자바8, 9로 넘어오면서 부터는 인터페이스에서도 디폴트 메서드를 정의하거나 private 메서드를 정의하는것이 가능해 졌습니다.\n\n이처럼 인터페이스가 점점 추상 클래스의 역할까지 담당해 나가고 있고 인프런 강의 영상에서도 점점 추상클래스를 사용하지 않고 있다는 말을 들은적이 있습니다. 때문에 문득 그럼에도 추상클래스가 필요한 이유가 있을까?라는 의문을 갖고 찾아보게 되었습니다.\n\n- 인터페이스에선 `final` 메서드를 정의할 수 없다.\n    - 서브클래스에서 어떠한 메서드가 재정의 (오버라이드)되는 것을 의도적으로 막기 위해서는 final 메서드가 필요하다\n- 인터페이스는 상태를 갖지 못한다.\n- 커뮤니케이션 가치\n    - 인터페이스는 구현해야하는 존재\n    - 구현될 필요가 없는 인터페이스를 의도하고 작성하였지만 누군가는 인터페이스를 보고 구현해야 할 존재로 바라볼 수 있다. 즉, 사람들의 예상과 다른 코드를 작성하여 오해를 불러 일으키는 코드를 작성하게 된다.\n- 생성자를 선언하지 못한다.\n\nhttps://www.quora.com/Do-we-need-abstract-classes-anymore-when-we-have-Java-8s-interfaces-with-default-and-static-methods\n"},"__N_SSG":true},"page":"/[id]","query":{"id":"object13"},"buildId":"rHHwQgn4XzsFFzcKqsKPc","assetPrefix":"/TIL","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>