<!DOCTYPE html><html><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><link rel="apple-touch-icon" sizes="180x180" href="https://i.imgur.com/2nHGFTv.png"/><link rel="icon" type="image/png" sizes="32x32" href="https://i.imgur.com/2nHGFTv.png"/><link rel="icon" type="image/png" sizes="16x16" href="https://i.imgur.com/2nHGFTv.png"/><link rel="manifest" href="/site.webmanifest"/><link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5"/><meta name="msapplication-TileColor" content="#da532c"/><meta name="theme-color" content="#ffffff"/><title>[오브젝트] 2장 - 객체지향 프로그래밍</title><meta name="title" content="[오브젝트] 2장 - 객체지향 프로그래밍"/><meta name="description" content=""/><meta name="keywords" content=""/><meta name="robots" content="index, follow"/><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><meta name="language" content="Korean"/><meta name="author" content="Sanha Ko"/><meta property="og:title" content="[오브젝트] 2장 - 객체지향 프로그래밍"/><meta property="og:url" content="https://headf1rst.github.io/TIL/object2"/><meta property="og:type" content="blog"/><meta property="og:image" content="https://wikibook.co.kr/images/cover/m/9791158391409.png"/><meta property="og:description"/><meta name="next-head-count" content="22"/><link rel="preload" href="/TIL/_next/static/css/754b961274c075df.css" as="style"/><link rel="stylesheet" href="/TIL/_next/static/css/754b961274c075df.css" data-n-g=""/><link rel="preload" href="/TIL/_next/static/css/38994dd0aed51f22.css" as="style"/><link rel="stylesheet" href="/TIL/_next/static/css/38994dd0aed51f22.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/TIL/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/TIL/_next/static/chunks/webpack-ac557983bcc4c022.js" defer=""></script><script src="/TIL/_next/static/chunks/framework-2c79e2a64abdb08b.js" defer=""></script><script src="/TIL/_next/static/chunks/main-dc8c1543918dad35.js" defer=""></script><script src="/TIL/_next/static/chunks/pages/_app-421e211a78340d83.js" defer=""></script><script src="/TIL/_next/static/chunks/202-7f08bae5ecc79443.js" defer=""></script><script src="/TIL/_next/static/chunks/pages/%5Bid%5D-e822cf87f2ef122d.js" defer=""></script><script src="/TIL/_next/static/DgHcyLVbQaP3fKIpTojx6/_buildManifest.js" defer=""></script><script src="/TIL/_next/static/DgHcyLVbQaP3fKIpTojx6/_ssgManifest.js" defer=""></script></head><body><div id="__next"><nav class="flex bg-white sticky top-0 left-0 z-50 justify-between items-center border-b-2 border-gray-100 py-3 md:justify-start md:space-x-10 px-10 sm:px-5 dark:bg-[#0d1117] dark:text-[#c9d1d9] dark:border-gray-600"><div class="flex justify-start"><a href="/TIL"><div class="flex items-center gap-2 cursor-pointer"><img src="https://i.imgur.com/2nHGFTv.png" width="40" height="40" alt="블로그 아이콘"/><h1 class="text-lg ">산하개발실록</h1></div></a></div><div class="flex justify-between gap-10 sm:hidden"><a href="/TIL"><button class="font-light hover:text-indigo-300 text-base">Home</button></a><a href="/TIL/category"><button class="font-light hover:text-indigo-300 text-base">Category</button></a><a href="https://plain-composer-c65.notion.site/29c7640fdf054059b6ea28ed61189bfb" target="_blank" rel="noreferrer" class="hover:text-indigo-300 text-base font-light flex gap-1">About<span class="flex justify-center" style="align-items:center"><svg stroke="currentColor" fill="currentColor" stroke-width="0" viewBox="0 0 24 24" height="1em" width="1em" xmlns="http://www.w3.org/2000/svg"><path d="m13 3 3.293 3.293-7 7 1.414 1.414 7-7L21 11V3z"></path><path d="M19 19H5V5h7l-2-2H5c-1.103 0-2 .897-2 2v14c0 1.103.897 2 2 2h14c1.103 0 2-.897 2-2v-5l-2-2v7z"></path></svg></span></a></div><svg stroke="currentColor" fill="currentColor" stroke-width="0" viewBox="0 0 512 512" class="lg:hidden" height="25" width="25" xmlns="http://www.w3.org/2000/svg"><path d="M32 96v64h448V96H32zm0 128v64h448v-64H32zm0 128v64h448v-64H32z"></path></svg></nav><main class="dark:bg-[#0d1117] h-screen pb-10"><div class="flex flex-col w-3/5 sm:w-5/6 m-auto pt-20 pb-20 gap-10 dark:bg-[#0d1117] dark:text-[#c9d1d9]"><ul id="scroll-spy" class="sm:hidden p-10 fixed top-50 right-0 h-full w-1/5 text-gray-500 dark:text-[#c9d1d9]"></ul><div class="text-5xl font-bold">[오브젝트] 2장 - 객체지향 프로그래밍</div><div class="flex flex-col gap-2"><div class="text-base text-gray-600 dark:text-gray-300">2022-08-29 10:00</div><div class="flex flex-wrap gap-2 dark:text-black sm:m-0"><span class="p-1 pl-3 pr-3 rounded-md bg-indigo-100 hover:bg-indigo-200 cursor-pointer transition ease-in-out duration-200 text-sm">object</span></div></div><div class="markdown-body" style="font-size:17px"><p>클래스를 먼저 결정하고, 어떤 <code node="[object Object]">속성</code>과 <code node="[object Object]">메서드</code>가 필요한지 고민하는것리 아니라 <code node="[object Object]">객체</code>에 초점을 맞춰야한다</p>
<ol>
<li>
<p>어떤 클래스가 필요한지 이전에 어떤 객체가 필요한지 고민하라
클래스는 공통적인 상태, 행동을 공유하는 객체를 추상화한것</p>
</li>
<li>
<p>객체는 독립적인 존재가아닌 협력하는 공동체의 일원이다</p>
</li>
</ol>
<ul>
<li>객체의 윤곽을 잡고 공통된 특성과 상태를 가진 객체들을 <strong>타입</strong> 으로 분류하라</li>
<li>타입을 기반으로 클래스를 구현하라</li>
</ul>
<p>클래스의 내부와 외부를 구분. 경계를 명확하게하여 객체의 자율성을 보장한다 -&gt; 개발자의 구현의 자유 제공</p>
<p>객체는 상태와 행동을 갖고 스스로 판단하고 행동하는 자율적인 존재</p>
<p>데이터와 기능을 객체 내부로 함께 묶는것 -&gt; <code node="[object Object]">캡슐화</code></p>
<ul>
<li>객체를 이용해서 타입을 정의하도록 하자<!-- -->
<ul>
<li>의미를 명시적이고 분명하게 표현 할 수 있으며 이는 설계의 명확성과 유연성을 높인다</li>
</ul>
</li>
</ul>
<p>협력 관점에서 어떤 객체가 필요할지 결정하고 객체들의 공통 상태와 행위를 구현하기 위해 클래스를 작성</p>
<h3>의존성의 양면성</h3>
<p>코드의 의존성과 실행시점의 의존성은 다를수 있다.
두 의존성이 다르면 다를수록 코드는 더 유연해지고 확장성이 좋아진다.</p>
<p>반면 코드를 이해하기 위해서는 객체를 생성하고 연결하는 부분을 찾아야하기 때문에 코드를 이해하기는 힘들어진다</p>
<p>설계는 곧 <code node="[object Object]">트레이드오프의 산물</code>.</p>
<h3>다형성</h3>
<p>인터페이스 -&gt; 객체가 이해할 수 있는 메시지의 목록을 정의</p>
<p>메세지와 메서드는 다른개념이다.</p>
<p>예를들어 영화 객체가 할인 정책 객체의 인스턴스에 calculateDiscountPolicy 메시지를 전송한다.</p>
<p>실행되는 메서드는 영화와 협력하는 객체, 즉 메시지를 수신하는 객체의 클래스가 무엇이냐에 따라 달라진다. - <code node="[object Object]">다형성</code></p>
<p>다형성은 객체지향 프로그램의 컴파일 시간 의존성과 실핼 시간 의존성이 다를 수 있다는 사실을 기반으로 한다</p>
<p>다형적 협력에 참여하는 객체들은 모두 같은 메시지를 이해할 수 있어야 한다 -&gt; 인터페이스가 동일해야 한다</p>
<p>인터페이스를 통일하기 위해 사용한 방법 -&gt; 상속</p>
<p><strong>동적 바인딩:</strong> 메시지와 메서드를 실행 시점에 바인딩</p>
<p><strong>정적 바인딩</strong>: 컴파일 시점에 실행될 함수나 프로시저를 결정하는것</p>
<p>우리는 동적 바인딩 메커니즘을 사용하여 컴파일 시점의 의존성과 실행 시점의 의존성을 분리하고 하나의 메시지를 선택적으로 다른 메서드에 연결할 수 있다</p>
<p>상속을 사용하여 동일한 인터페이스를 공유하는 클래스들을 하나의 <strong>타입 계층</strong>으로 묶을수 있다</p>
<h3>구현 상속과 인터페이스 상속</h3>
<p><strong>구현 상속 (서브클래싱)</strong> : 코드 재사용 목적으로 상속을 사용한 경우</p>
<p><strong>인터페이스 상속 (서브타이핑)</strong> : 다형적인 협력을 위해 부모 클래스와 자식 클래스가 인터페이스를 공유 할 수 있도록 상속을 사용한 경우</p>
<p>인터페이스를 재사용할 목적이 아니라 구현을 재사용할 목적으로 상속을 사용하면 변경에 취약한 코드를 생산할 수 있다</p>
<h3>추상화의 장점</h3>
<ul>
<li>추상화의 계층만 따로 보면 요구사항의 정책을 높은 수준에서 서술할 수 있다</li>
<li>상위 정책을 기술하여 어플리케이션의 협력 흐름을 술</li>
<li>설계가 유연해진다</li>
</ul>
<h3>유연한 설계</h3>
<p>예외 케이스를 최소화하고 일관성을 유지할 수 있는 방법을 선택하라</p>
<p>유연성이 필요한 곳에 추상화를 사용하라</p>
<h3>코드 재사용</h3>
<p>코드를 재사용 하기 위해서는 상속보다는 <strong>합성</strong>을 사용하라</p>
<h3>코드 재사용으로 상속을 지양하는 이유</h3>
<p>코드 재사용을 목적으로 상속을 사용하면 설계에 안좋은 영형을 끼친다.</p>
<ul>
<li>캡슐화를 위반
상속을 이용하기 위해서 개발자는 부모 클래스릐 내부 구조를 알아야한다</li>
</ul>
<p>결과적으로 부모 클래스가 자식 클랴스에 노출되어 캡슐화가 약화된다</p>
<p>캡슐화가 약화되어 자식이 부모 클래스와 강하게 결합되기 때문에 부모 클래스가 변경되면 자식 클래스도 함께 변경되야 한다</p>
<ul>
<li>유연하지 못한 설계
부모 클래스와 자식 클래스 사이의 관계를 컴파일 시점에 결정하기 때문에 실행 시점에 객체 종류 변경이 불가능</li>
</ul>
<h3>합성을 사용해서 코드를 재사용하자</h3>
<p><code node="[object Object]">합성</code></p>
<ul>
<li>인터페이스에 정의된 메시지를 통해서만 코드를 재사용하는 방법.</li>
</ul>
<pre><div node="[object Object]" style="display:block;overflow-x:auto;padding:0.5em;color:#383a42;background:#fafafa"><code class="language-java" style="white-space:pre"><span style="color:#a626a4">public</span><span> </span><span class="hljs-class" style="color:#a626a4">class</span><span class="hljs-class"> </span><span class="hljs-class" style="color:#4078f2">Movie</span><span class="hljs-class"> </span><span>{
</span>    ...
<span>    </span><span style="color:#a626a4">private</span><span> DiscountPolicy discountPolicy;
</span>    ...
<!-- -->
<span>    </span><span class="hljs-function" style="color:#a626a4">public</span><span class="hljs-function"> Money </span><span class="hljs-function" style="color:#4078f2">calculateMovieFee</span><span class="hljs-function hljs-params">(Screening screening)</span><span class="hljs-function"> </span><span>{
</span><span>        </span><span style="color:#a626a4">return</span><span> fee.minus(discountPolicy.calculateDiscountAmount(screening));
</span>    }
<!-- -->}</code></div></pre>
<p><code node="[object Object]">Movie</code>는 요금 계산을 위해 <code node="[object Object]">DiscountPolicy</code>의 <code node="[object Object]">calculateDiscountAmount()</code> 코드를 재사용한다.</p>
<p><code node="[object Object]">Movie</code>는 <code node="[object Object]">DiscountPolicy</code>인터페이스를 통해 약하게 결합되어있다 (의존하고 있다).</p>
<p>실제로 <code node="[object Object]">Movie</code>는 <code node="[object Object]">DiscountPolicy</code>가 외부에 <code node="[object Object]">calculateDiscountAmount()</code> 메서드를 제공한다는 것만 알고 내부 구현에 대해서는 전혀 모른다.</p>
<p>합성의 장점은 다음과 같다</p>
<ul>
<li>
<p>구현을 효과적으로 캡슐화
인터페이스에 정의된 메시지를 통해서만 재사용 가능하기 때문에.</p>
</li>
<li>
<p>유연한 설계
의존하는 인스턴스를 교체하는것이 쉽다.</p>
</li>
</ul>
<p>상속은 클래스를 통해 강하게 결합된다.
합성은 메시지를 통해 느슨하게 결합된다.</p>
<h3>상속을 무조건 쓰지 말라는건 아니다</h3>
<p>코드를 재사용하는 경우에는 상속보다는 합성을 선호하는 것이 옳다.</p>
<p>하지만 다형성을 위해 인터페이스를 재사용하는 경우에는 상속과 합성을 함께 조합해서 사용한다.</p>
<hr/>
<p><code node="[object Object]">객체지향 설계의 핵심</code>:</p>
<ul>
<li>적절한 협력을 식별</li>
<li>협력에 필요한 역할을 정의</li>
<li>역할을 수행할 수 있는 적절한 객체에 적절한 책임을 할당</li>
</ul>
<h3>느낀점</h3>
<p>이번 장을 읽으면서, 과거에 한 친구가 단순히 중복을 제거하는 목적으로 상속을 사용한 설계를 저에게 보여줬던 것이 생각났습니다.</p>
<p>당시에도 그러한 설계가 좋지 않은 설계라는걸 알고는 있었지만 모호하게 알고있었기 때문에, 그 친구에게 제 의견을 제대로 전달하지 못했던 경험을 하였습니다.</p>
<p>나 혼자서 아무리 유연한 코드를 짜고 객체지향에 대해 잘 안다고 해도 결국에 하나의 프로젝트는 조직원들이 다 같이 완성해 나가는 것이기 때문에, 팀원들을 설득하지 못한다면 결과물은 객체지향적이지 않은 코드가 나오고 말것입니다.</p>
<p>따라서 내가 배운것을 스스로 적용해 볼 수 있는 수준에서 그치지 않고 누군가에게 설명하고 설득할 수 있는 수준까지 공부하는것이 중요하다는 생각을 해보았습니다.</p></div><section></section></div></main></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"postData":{"id":"object2","title":"[오브젝트] 2장 - 객체지향 프로그래밍","category":"object","thumbnail":"https://wikibook.co.kr/images/cover/m/9791158391409.png","tags":"object","date":"2022-08-29 10:00","preview":"\n클래스를 먼저 결정하고, 어떤 `속성`과 `메서드`가 필요한지 고민하는것리 아니라 `객체`에 초점을 맞춰야한다\n\n1. 어떤 클래스가 필요한지 이전에 어떤 객체가 필요한지 고민하라\n   클래스는 공통적인 상태, 행동을 공유하는 객체를 추상화한것\n\n2."},"detail":"\n클래스를 먼저 결정하고, 어떤 `속성`과 `메서드`가 필요한지 고민하는것리 아니라 `객체`에 초점을 맞춰야한다\n\n1. 어떤 클래스가 필요한지 이전에 어떤 객체가 필요한지 고민하라\n   클래스는 공통적인 상태, 행동을 공유하는 객체를 추상화한것\n\n2. 객체는 독립적인 존재가아닌 협력하는 공동체의 일원이다\n\n- 객체의 윤곽을 잡고 공통된 특성과 상태를 가진 객체들을 **타입** 으로 분류하라\n- 타입을 기반으로 클래스를 구현하라\n\n클래스의 내부와 외부를 구분. 경계를 명확하게하여 객체의 자율성을 보장한다 -\u003e 개발자의 구현의 자유 제공\n\n객체는 상태와 행동을 갖고 스스로 판단하고 행동하는 자율적인 존재\n\n데이터와 기능을 객체 내부로 함께 묶는것 -\u003e `캡슐화`\n\n- 객체를 이용해서 타입을 정의하도록 하자\n    - 의미를 명시적이고 분명하게 표현 할 수 있으며 이는 설계의 명확성과 유연성을 높인다\n\n협력 관점에서 어떤 객체가 필요할지 결정하고 객체들의 공통 상태와 행위를 구현하기 위해 클래스를 작성\n\n### 의존성의 양면성\n\n코드의 의존성과 실행시점의 의존성은 다를수 있다.\n두 의존성이 다르면 다를수록 코드는 더 유연해지고 확장성이 좋아진다.\n\n반면 코드를 이해하기 위해서는 객체를 생성하고 연결하는 부분을 찾아야하기 때문에 코드를 이해하기는 힘들어진다\n\n설계는 곧 `트레이드오프의 산물`.\n\n### 다형성\n\n\n인터페이스 -\u003e 객체가 이해할 수 있는 메시지의 목록을 정의\n\n메세지와 메서드는 다른개념이다.\n\n예를들어 영화 객체가 할인 정책 객체의 인스턴스에 calculateDiscountPolicy 메시지를 전송한다.\n\n실행되는 메서드는 영화와 협력하는 객체, 즉 메시지를 수신하는 객체의 클래스가 무엇이냐에 따라 달라진다. - `다형성`\n\n다형성은 객체지향 프로그램의 컴파일 시간 의존성과 실핼 시간 의존성이 다를 수 있다는 사실을 기반으로 한다\n\n다형적 협력에 참여하는 객체들은 모두 같은 메시지를 이해할 수 있어야 한다 -\u003e 인터페이스가 동일해야 한다\n\n인터페이스를 통일하기 위해 사용한 방법 -\u003e 상속\n\n**동적 바인딩:** 메시지와 메서드를 실행 시점에 바인딩\n\n**정적 바인딩**: 컴파일 시점에 실행될 함수나 프로시저를 결정하는것\n\n우리는 동적 바인딩 메커니즘을 사용하여 컴파일 시점의 의존성과 실행 시점의 의존성을 분리하고 하나의 메시지를 선택적으로 다른 메서드에 연결할 수 있다\n\n상속을 사용하여 동일한 인터페이스를 공유하는 클래스들을 하나의 **타입 계층**으로 묶을수 있다\n\n### 구현 상속과 인터페이스 상속\n\n**구현 상속 (서브클래싱)** : 코드 재사용 목적으로 상속을 사용한 경우\n\n**인터페이스 상속 (서브타이핑)** : 다형적인 협력을 위해 부모 클래스와 자식 클래스가 인터페이스를 공유 할 수 있도록 상속을 사용한 경우\n\n인터페이스를 재사용할 목적이 아니라 구현을 재사용할 목적으로 상속을 사용하면 변경에 취약한 코드를 생산할 수 있다\n\n### 추상화의 장점\n- 추상화의 계층만 따로 보면 요구사항의 정책을 높은 수준에서 서술할 수 있다\n- 상위 정책을 기술하여 어플리케이션의 협력 흐름을 술\n- 설계가 유연해진다\n\n### 유연한 설계\n예외 케이스를 최소화하고 일관성을 유지할 수 있는 방법을 선택하라\n\n유연성이 필요한 곳에 추상화를 사용하라\n\n### 코드 재사용\n코드를 재사용 하기 위해서는 상속보다는 **합성**을 사용하라\n\n### 코드 재사용으로 상속을 지양하는 이유\n\n코드 재사용을 목적으로 상속을 사용하면 설계에 안좋은 영형을 끼친다.\n\n- 캡슐화를 위반\n  상속을 이용하기 위해서 개발자는 부모 클래스릐 내부 구조를 알아야한다\n\n결과적으로 부모 클래스가 자식 클랴스에 노출되어 캡슐화가 약화된다\n\n캡슐화가 약화되어 자식이 부모 클래스와 강하게 결합되기 때문에 부모 클래스가 변경되면 자식 클래스도 함께 변경되야 한다\n\n- 유연하지 못한 설계\n  부모 클래스와 자식 클래스 사이의 관계를 컴파일 시점에 결정하기 때문에 실행 시점에 객체 종류 변경이 불가능\n\n### 합성을 사용해서 코드를 재사용하자\n\n`합성`\n- 인터페이스에 정의된 메시지를 통해서만 코드를 재사용하는 방법.\n\n``` java\npublic class Movie {\n    ...\n    private DiscountPolicy discountPolicy;\n    ...\n\n    public Money calculateMovieFee(Screening screening) {\n        return fee.minus(discountPolicy.calculateDiscountAmount(screening));\n    }\n}\n```\n\n`Movie`는 요금 계산을 위해 `DiscountPolicy`의 `calculateDiscountAmount()` 코드를 재사용한다.\n\n`Movie`는 `DiscountPolicy`인터페이스를 통해 약하게 결합되어있다 (의존하고 있다).\n\n실제로 `Movie`는 `DiscountPolicy`가 외부에 `calculateDiscountAmount()` 메서드를 제공한다는 것만 알고 내부 구현에 대해서는 전혀 모른다.\n\n\n합성의 장점은 다음과 같다\n\n- 구현을 효과적으로 캡슐화\n  인터페이스에 정의된 메시지를 통해서만 재사용 가능하기 때문에.\n\n- 유연한 설계\n  의존하는 인스턴스를 교체하는것이 쉽다.\n\n상속은 클래스를 통해 강하게 결합된다.\n합성은 메시지를 통해 느슨하게 결합된다.\n\n### 상속을 무조건 쓰지 말라는건 아니다\n\n코드를 재사용하는 경우에는 상속보다는 합성을 선호하는 것이 옳다.\n\n하지만 다형성을 위해 인터페이스를 재사용하는 경우에는 상속과 합성을 함께 조합해서 사용한다.\n\n---\n\n`객체지향 설계의 핵심`:\n- 적절한 협력을 식별\n- 협력에 필요한 역할을 정의\n- 역할을 수행할 수 있는 적절한 객체에 적절한 책임을 할당\n\n### 느낀점\n\n이번 장을 읽으면서, 과거에 한 친구가 단순히 중복을 제거하는 목적으로 상속을 사용한 설계를 저에게 보여줬던 것이 생각났습니다.\n\n당시에도 그러한 설계가 좋지 않은 설계라는걸 알고는 있었지만 모호하게 알고있었기 때문에, 그 친구에게 제 의견을 제대로 전달하지 못했던 경험을 하였습니다.\n\n나 혼자서 아무리 유연한 코드를 짜고 객체지향에 대해 잘 안다고 해도 결국에 하나의 프로젝트는 조직원들이 다 같이 완성해 나가는 것이기 때문에, 팀원들을 설득하지 못한다면 결과물은 객체지향적이지 않은 코드가 나오고 말것입니다.\n\n따라서 내가 배운것을 스스로 적용해 볼 수 있는 수준에서 그치지 않고 누군가에게 설명하고 설득할 수 있는 수준까지 공부하는것이 중요하다는 생각을 해보았습니다.\n"},"__N_SSG":true},"page":"/[id]","query":{"id":"object2"},"buildId":"DgHcyLVbQaP3fKIpTojx6","assetPrefix":"/TIL","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>