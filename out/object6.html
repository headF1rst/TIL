<!DOCTYPE html><html><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><link rel="apple-touch-icon" sizes="180x180" href="https://i.imgur.com/2nHGFTv.png"/><link rel="icon" type="image/png" sizes="32x32" href="https://i.imgur.com/2nHGFTv.png"/><link rel="icon" type="image/png" sizes="16x16" href="https://i.imgur.com/2nHGFTv.png"/><link rel="manifest" href="/site.webmanifest"/><link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5"/><meta name="msapplication-TileColor" content="#da532c"/><meta name="theme-color" content="#ffffff"/><title>[오브젝트] 6장 - 메시지와 인터페이스</title><meta name="title" content="[오브젝트] 6장 - 메시지와 인터페이스"/><meta name="description" content=""/><meta name="keywords" content=""/><meta name="robots" content="index, follow"/><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><meta name="language" content="Korean"/><meta name="author" content="Sanha Ko"/><meta property="og:title" content="[오브젝트] 6장 - 메시지와 인터페이스"/><meta property="og:url" content="https://headf1rst.github.io/TIL/object6"/><meta property="og:type" content="blog"/><meta property="og:image" content="https://wikibook.co.kr/images/cover/m/9791158391409.png"/><meta property="og:description"/><meta name="next-head-count" content="22"/><link rel="preload" href="/TIL/_next/static/css/754b961274c075df.css" as="style"/><link rel="stylesheet" href="/TIL/_next/static/css/754b961274c075df.css" data-n-g=""/><link rel="preload" href="/TIL/_next/static/css/38994dd0aed51f22.css" as="style"/><link rel="stylesheet" href="/TIL/_next/static/css/38994dd0aed51f22.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/TIL/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/TIL/_next/static/chunks/webpack-ac557983bcc4c022.js" defer=""></script><script src="/TIL/_next/static/chunks/framework-2c79e2a64abdb08b.js" defer=""></script><script src="/TIL/_next/static/chunks/main-dc8c1543918dad35.js" defer=""></script><script src="/TIL/_next/static/chunks/pages/_app-421e211a78340d83.js" defer=""></script><script src="/TIL/_next/static/chunks/202-7f08bae5ecc79443.js" defer=""></script><script src="/TIL/_next/static/chunks/pages/%5Bid%5D-e822cf87f2ef122d.js" defer=""></script><script src="/TIL/_next/static/DgHcyLVbQaP3fKIpTojx6/_buildManifest.js" defer=""></script><script src="/TIL/_next/static/DgHcyLVbQaP3fKIpTojx6/_ssgManifest.js" defer=""></script></head><body><div id="__next"><nav class="flex bg-white sticky top-0 left-0 z-50 justify-between items-center border-b-2 border-gray-100 py-3 md:justify-start md:space-x-10 px-10 sm:px-5 dark:bg-[#0d1117] dark:text-[#c9d1d9] dark:border-gray-600"><div class="flex justify-start"><a href="/TIL"><div class="flex items-center gap-2 cursor-pointer"><img src="https://i.imgur.com/2nHGFTv.png" width="40" height="40" alt="블로그 아이콘"/><h1 class="text-lg ">산하개발실록</h1></div></a></div><div class="flex justify-between gap-10 sm:hidden"><a href="/TIL"><button class="font-light hover:text-indigo-300 text-base">Home</button></a><a href="/TIL/category"><button class="font-light hover:text-indigo-300 text-base">Category</button></a><a href="https://plain-composer-c65.notion.site/29c7640fdf054059b6ea28ed61189bfb" target="_blank" rel="noreferrer" class="hover:text-indigo-300 text-base font-light flex gap-1">About<span class="flex justify-center" style="align-items:center"><svg stroke="currentColor" fill="currentColor" stroke-width="0" viewBox="0 0 24 24" height="1em" width="1em" xmlns="http://www.w3.org/2000/svg"><path d="m13 3 3.293 3.293-7 7 1.414 1.414 7-7L21 11V3z"></path><path d="M19 19H5V5h7l-2-2H5c-1.103 0-2 .897-2 2v14c0 1.103.897 2 2 2h14c1.103 0 2-.897 2-2v-5l-2-2v7z"></path></svg></span></a></div><svg stroke="currentColor" fill="currentColor" stroke-width="0" viewBox="0 0 512 512" class="lg:hidden" height="25" width="25" xmlns="http://www.w3.org/2000/svg"><path d="M32 96v64h448V96H32zm0 128v64h448v-64H32zm0 128v64h448v-64H32z"></path></svg></nav><main class="dark:bg-[#0d1117] h-screen pb-10"><div class="flex flex-col w-3/5 sm:w-5/6 m-auto pt-20 pb-20 gap-10 dark:bg-[#0d1117] dark:text-[#c9d1d9]"><ul id="scroll-spy" class="sm:hidden p-10 fixed top-50 right-0 h-full w-1/5 text-gray-500 dark:text-[#c9d1d9]"></ul><div class="text-5xl font-bold">[오브젝트] 6장 - 메시지와 인터페이스</div><div class="flex flex-col gap-2"><div class="text-base text-gray-600 dark:text-gray-300">2022-09-26 10:00</div><div class="flex flex-wrap gap-2 dark:text-black sm:m-0"><span class="p-1 pl-3 pr-3 rounded-md bg-indigo-100 hover:bg-indigo-200 cursor-pointer transition ease-in-out duration-200 text-sm">object</span></div></div><div class="markdown-body" style="font-size:17px"><p>객체지향 어플리케이션의 가장 중요한 재료는 객체들이 주고받는 <code node="[object Object]">메시지</code> 이다.</p>
<p>유연하고 재사용 가능한 퍼블릭 인터페이스를 만드는 설계 원칙과 기법이 이번장의 핵심</p>
<h2>협력과 메시지</h2>
<ul>
<li>클라이언트 - 서버 모델</li>
<li>메시지와 메시지 전송<!-- -->
<ul>
<li>메시지 = 오퍼레이션명 + 인자<!-- -->
<ul>
<li><code node="[object Object]">isSatisfiedBy(screening)</code></li>
</ul>
</li>
<li>메시지 전송 = 오퍼레이션명 + 인자 + 메시지 수신자<!-- -->
<ul>
<li><code node="[object Object]">condition.isSatisfiedBy(screening)</code></li>
</ul>
</li>
</ul>
</li>
<li>메서드<!-- -->
<ul>
<li>메시지를 수신했을 때 실제로 실행되는 함수 또는 프로시저</li>
</ul>
</li>
</ul>
<h3>실행 시점에 메시지와 메서드를 바인딩하는 메커니즘</h3>
<ul>
<li>
<p>두 객체 사이의 결합도를 낮춤</p>
</li>
<li>
<p>유연하고 확장 가능한 코드 설계</p>
</li>
<li>
<p>퍼블릭 인터페이스</p>
<ul>
<li>객체가 의사소통을 위해 외부에 공개하는 <strong>메시지의 집합</strong></li>
</ul>
</li>
<li>
<p>오퍼레이션</p>
<ul>
<li>수행 가능한 어떤 행동에 대한 추상화</li>
<li>퍼블릭 인터페이스에 포함된 메시지</li>
</ul>
</li>
<li>
<p>메서드</p>
<ul>
<li>메시지를 수신했을때 실제로 실행되는 코드</li>
<li>오퍼레이션의 구현</li>
</ul>
</li>
<li>
<p>시그니처</p>
<ul>
<li>오퍼레이션이나 메서드의 명세를 나타낸것<!-- -->
<ul>
<li>오퍼레이션의 이름과 파라미터의 목록의 합</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>클라이언트 -&gt; 메시지 전송 -&gt; 오퍼레이션 호출 -&gt; 서버, 메서드 실행</p>
<h2>인터페이스와 설계 품질</h2>
<p>좋은 인터페이스란?
최소한의 인터페이스와 추상적인 인터페이스라는 조건을 만족해야한다.</p>
<ul>
<li>최소한의 인터페이스<!-- -->
<ul>
<li>꼭 필요한 오퍼레이션만을 인터페이스에 포함</li>
</ul>
</li>
<li>추상적인 인터페이스<!-- -->
<ul>
<li>어떻게 수행하는지가 아닌 무엇을 하는지를 표현</li>
</ul>
</li>
</ul>
<p>책임 주도 설계 방법을 통해서 좋은 인터페이스를 설계할 수 있다.
(메시지가 객체를 선택하게 하라)</p>
<h3>퍼블릭 인터페이스의 품질에 대한 원칙 및 기법</h3>
<ul>
<li>디미터 법칙<!-- -->
<ul>
<li>낯선 자에게 말하지 말고 인접한 이웃하고만 말하라</li>
<li>협력 경로를 제한하라</li>
</ul>
</li>
<li>묻지말고 시켜라<!-- -->
<ul>
<li>객체의 상태에 대해 묻지 말고 원하는 것을 시켜라</li>
<li>내부의 상태를 이용해 어떤 결정을 내리는 로직이 객체 외부에 존재해서는 안된다.<!-- -->
<ul>
<li>캡슐화 위반</li>
</ul>
</li>
<li>상태를 묻는 오퍼레이션을 행동을 요청하는 오퍼레이션으로 대체하라</li>
</ul>
</li>
<li>의도를 드러내는 인터페이스<!-- -->
<ul>
<li>메서드의 이름은 어떻게가 아니라 무엇을 하는지를 드러내야 한다.</li>
<li>클라이언트 관점에서 협력을 바라보고 클라이언트의 의도를 담을 수 있는 메서드명을 선
택하라.</li>
<li>클라이언트가 객체에게 무엇을 원하는지를 명확하게 표현해야 한다.</li>
<li>메서드가 무엇을 하느냐에 초점을 두면 동일한 작업을 수행하는 메서드들을 하나의 타입 계층으로 묶을 수 있는 가능성이 커진다.</li>
</ul>
</li>
<li>명령 - 쿼리 분리 원칙<!-- -->
<ul>
<li>명령 = 프로시저<!-- -->
<ul>
<li>부수효과를 발생시킨다.</li>
<li>값을 반환할 수 없다.</li>
</ul>
</li>
<li>쿼리 = 함수<!-- -->
<ul>
<li>부수효과를 발생시킬 수 없다.</li>
<li>값을 반환한다.</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>어떤 메서드가 부수효과를 가지는지 확인하기 위해서 메서드의 반환 값을 가지는지 여부만 확인하면 된다.</p>
<p>코드는 예측 가능하고 이해하기 쉬우며 디버깅이 용이한 동시에 유지보수가 수월해진다.</p>
<pre><div node="[object Object]" style="display:block;overflow-x:auto;padding:0.5em;color:#383a42;background:#fafafa"><code class="language-java" style="white-space:pre"><span style="color:#a626a4">if</span><span> (!event.isSatisfied(schedule)) { </span><span style="color:#a0a1a7;font-style:italic">// 쿼리</span><span>
</span><span>	event.reschedule(schedule); </span><span style="color:#a0a1a7;font-style:italic">// 명령</span><span>
</span>}</code></div></pre>
<p>명령과 쿼리가 분리되지 않은 안좋은 예</p>
<pre><div node="[object Object]" style="display:block;overflow-x:auto;padding:0.5em;color:#383a42;background:#fafafa"><code class="language-java" style="white-space:pre"><span style="color:#a626a4">public</span><span> </span><span class="hljs-class" style="color:#a626a4">class</span><span class="hljs-class"> </span><span class="hljs-class" style="color:#4078f2">Event</span><span class="hljs-class"> </span><span>{
</span>
<span>	</span><span class="hljs-function" style="color:#a626a4">public</span><span class="hljs-function"> </span><span class="hljs-function" style="color:#a626a4">boolean</span><span class="hljs-function"> </span><span class="hljs-function" style="color:#4078f2">isSatisfied</span><span class="hljs-function hljs-params">(RecurringSchedule schedule)</span><span class="hljs-function"> </span><span>{
</span><span>		</span><span style="color:#a626a4">if</span><span> (from.getDayOfWeek() != schedule.getDayOfWeek() ||
</span>		!from.toLocalTime().equals(schedule.getFrom()) || 
<!-- -->		!duration.equals(schedule.getDuration())) {
<span>			reschedule(schedule); </span><span style="color:#a0a1a7;font-style:italic">// BAD !! 쿼리에 명령이 포함됨.</span><span>
</span><span>			</span><span style="color:#a626a4">return</span><span> </span><span style="color:#a626a4">false</span><span>;
</span>		}
<span>		</span><span style="color:#a626a4">return</span><span> </span><span style="color:#a626a4">true</span><span>;
</span>	}
<!-- -->}</code></div></pre>
<h2>참조 투명성과 함수형 프로그래밍</h2>
<p>명령과 쿼리를 분리함으로써 명령형 언어의 틀 안에서 <strong>참조 투명성</strong>의 장점을 누릴 수 있게 된다.</p>
<ul>
<li>참조 투명성<!-- -->
<ul>
<li>어떤 표현식 e가 있을 때 e의 값으로 e가 나타나는 모든 위치를 교체하더라도 결과가 달라지지 않는 특성</li>
<li>동일한 값을 출력하는 함수의 특성을 사용하여 식을 값으로 치환하는 방법을 통해 결과를 쉽게 계산해준다.</li>
</ul>
</li>
</ul>
<h2>느낀점</h2>
<p>설계는 결국 트레이드오프의 산물이며 원칙을 추종하지 않고 상황에 따라 원칙을 무시할 수 있는 판단이 필요하다. 이러한 판단은 수많은 프로젝트 설계 경험을 통해서 얻을 수 있겠지만 주니어 개발자인 우리가 어떻게 하면 이러한 역량을 빠르게 쌓을 수 있을지 고민해 보았다.</p>
<p>개인적인 생각으로는 구성원간의 설계에 대한 토론이 설계 역량을 쌓는데 가장 좋은 수단이 될 수 있을것이라고 생각한다. 다양한 구성원들간 의견 공유를 통해서 다른 사람의 생각을 들어보고 내가 미처 생각해보지 못한 관점을 듣는 것이 설계 역량을 키우는데 도움이 될 것이라고 생각한다.</p>
<p>이를 위해서는 자신의 의견을 언제든지 말할 수 있는 조직문화가 기반이 되어야 하며 이러한 조직내 분위기를 만들기 위한 노력 또한 우리가 해야하는 역할이지 않을까 생각해 보았다.</p></div><section></section></div></main></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"postData":{"id":"object6","title":"[오브젝트] 6장 - 메시지와 인터페이스","category":"object","thumbnail":"https://wikibook.co.kr/images/cover/m/9791158391409.png","tags":"object","date":"2022-09-26 10:00","preview":"\n\n객체지향 어플리케이션의 가장 중요한 재료는 객체들이 주고받는 `메시지` 이다.\n\n유연하고 재사용 가능한 퍼블릭 인터페이스를 만드는 설계 원칙과 기법이 이번장의 핵심\n\n## 협력과 메시지\n- 클라이언트 - 서버 모델\n- 메시지와 메시지 전송\n    "},"detail":"\n\n객체지향 어플리케이션의 가장 중요한 재료는 객체들이 주고받는 `메시지` 이다.\n\n유연하고 재사용 가능한 퍼블릭 인터페이스를 만드는 설계 원칙과 기법이 이번장의 핵심\n\n## 협력과 메시지\n- 클라이언트 - 서버 모델\n- 메시지와 메시지 전송\n    - 메시지 = 오퍼레이션명 + 인자\n        - `isSatisfiedBy(screening)`\n    - 메시지 전송 = 오퍼레이션명 + 인자 + 메시지 수신자\n        - `condition.isSatisfiedBy(screening)`\n- 메서드\n    - 메시지를 수신했을 때 실제로 실행되는 함수 또는 프로시저\n\n### 실행 시점에 메시지와 메서드를 바인딩하는 메커니즘\n- 두 객체 사이의 결합도를 낮춤\n- 유연하고 확장 가능한 코드 설계\n\n- 퍼블릭 인터페이스\n    - 객체가 의사소통을 위해 외부에 공개하는 **메시지의 집합**\n- 오퍼레이션\n    - 수행 가능한 어떤 행동에 대한 추상화\n    - 퍼블릭 인터페이스에 포함된 메시지\n- 메서드\n    - 메시지를 수신했을때 실제로 실행되는 코드\n    - 오퍼레이션의 구현\n- 시그니처\n    - 오퍼레이션이나 메서드의 명세를 나타낸것\n        - 오퍼레이션의 이름과 파라미터의 목록의 합\n\n클라이언트 -\u003e 메시지 전송 -\u003e 오퍼레이션 호출 -\u003e 서버, 메서드 실행\n\n## 인터페이스와 설계 품질\n\n좋은 인터페이스란?\n최소한의 인터페이스와 추상적인 인터페이스라는 조건을 만족해야한다.\n\n- 최소한의 인터페이스\n    - 꼭 필요한 오퍼레이션만을 인터페이스에 포함\n- 추상적인 인터페이스\n    - 어떻게 수행하는지가 아닌 무엇을 하는지를 표현\n\n책임 주도 설계 방법을 통해서 좋은 인터페이스를 설계할 수 있다.\n(메시지가 객체를 선택하게 하라)\n\n### 퍼블릭 인터페이스의 품질에 대한 원칙 및 기법\n\n- 디미터 법칙\n    - 낯선 자에게 말하지 말고 인접한 이웃하고만 말하라\n    - 협력 경로를 제한하라\n- 묻지말고 시켜라\n    - 객체의 상태에 대해 묻지 말고 원하는 것을 시켜라\n    - 내부의 상태를 이용해 어떤 결정을 내리는 로직이 객체 외부에 존재해서는 안된다.\n        - 캡슐화 위반\n    - 상태를 묻는 오퍼레이션을 행동을 요청하는 오퍼레이션으로 대체하라\n- 의도를 드러내는 인터페이스\n    - 메서드의 이름은 어떻게가 아니라 무엇을 하는지를 드러내야 한다.\n    - 클라이언트 관점에서 협력을 바라보고 클라이언트의 의도를 담을 수 있는 메서드명을 선\n      택하라.\n    - 클라이언트가 객체에게 무엇을 원하는지를 명확하게 표현해야 한다.\n    - 메서드가 무엇을 하느냐에 초점을 두면 동일한 작업을 수행하는 메서드들을 하나의 타입 계층으로 묶을 수 있는 가능성이 커진다.\n- 명령 - 쿼리 분리 원칙\n    - 명령 = 프로시저\n        - 부수효과를 발생시킨다.\n        - 값을 반환할 수 없다.\n    - 쿼리 = 함수\n        - 부수효과를 발생시킬 수 없다.\n        - 값을 반환한다.\n\n어떤 메서드가 부수효과를 가지는지 확인하기 위해서 메서드의 반환 값을 가지는지 여부만 확인하면 된다.\n\n코드는 예측 가능하고 이해하기 쉬우며 디버깅이 용이한 동시에 유지보수가 수월해진다.\n\n``` java\nif (!event.isSatisfied(schedule)) { // 쿼리\n\tevent.reschedule(schedule); // 명령\n}\n```\n\n명령과 쿼리가 분리되지 않은 안좋은 예\n\n``` java\npublic class Event {\n\n\tpublic boolean isSatisfied(RecurringSchedule schedule) {\n\t\tif (from.getDayOfWeek() != schedule.getDayOfWeek() ||\n\t\t!from.toLocalTime().equals(schedule.getFrom()) || \n\t\t!duration.equals(schedule.getDuration())) {\n\t\t\treschedule(schedule); // BAD !! 쿼리에 명령이 포함됨.\n\t\t\treturn false;\n\t\t}\n\t\treturn true;\n\t}\n}\n```\n\n## 참조 투명성과 함수형 프로그래밍\n\n명령과 쿼리를 분리함으로써 명령형 언어의 틀 안에서 **참조 투명성**의 장점을 누릴 수 있게 된다.\n\n- 참조 투명성\n    - 어떤 표현식 e가 있을 때 e의 값으로 e가 나타나는 모든 위치를 교체하더라도 결과가 달라지지 않는 특성\n    - 동일한 값을 출력하는 함수의 특성을 사용하여 식을 값으로 치환하는 방법을 통해 결과를 쉽게 계산해준다.\n\n## 느낀점\n\n설계는 결국 트레이드오프의 산물이며 원칙을 추종하지 않고 상황에 따라 원칙을 무시할 수 있는 판단이 필요하다. 이러한 판단은 수많은 프로젝트 설계 경험을 통해서 얻을 수 있겠지만 주니어 개발자인 우리가 어떻게 하면 이러한 역량을 빠르게 쌓을 수 있을지 고민해 보았다.\n\n개인적인 생각으로는 구성원간의 설계에 대한 토론이 설계 역량을 쌓는데 가장 좋은 수단이 될 수 있을것이라고 생각한다. 다양한 구성원들간 의견 공유를 통해서 다른 사람의 생각을 들어보고 내가 미처 생각해보지 못한 관점을 듣는 것이 설계 역량을 키우는데 도움이 될 것이라고 생각한다.\n\n이를 위해서는 자신의 의견을 언제든지 말할 수 있는 조직문화가 기반이 되어야 하며 이러한 조직내 분위기를 만들기 위한 노력 또한 우리가 해야하는 역할이지 않을까 생각해 보았다.\n"},"__N_SSG":true},"page":"/[id]","query":{"id":"object6"},"buildId":"DgHcyLVbQaP3fKIpTojx6","assetPrefix":"/TIL","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>