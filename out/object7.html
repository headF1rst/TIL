<!DOCTYPE html><html><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><link rel="apple-touch-icon" sizes="180x180" href="https://i.imgur.com/2nHGFTv.png"/><link rel="icon" type="image/png" sizes="32x32" href="https://i.imgur.com/2nHGFTv.png"/><link rel="icon" type="image/png" sizes="16x16" href="https://i.imgur.com/2nHGFTv.png"/><link rel="manifest" href="/site.webmanifest"/><link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5"/><meta name="msapplication-TileColor" content="#da532c"/><meta name="theme-color" content="#ffffff"/><title>[오브젝트] 7장 - 객체 분해</title><meta name="title" content="[오브젝트] 7장 - 객체 분해"/><meta name="description" content=""/><meta name="keywords" content=""/><meta name="robots" content="index, follow"/><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><meta name="language" content="Korean"/><meta name="author" content="Sanha Ko"/><meta property="og:title" content="[오브젝트] 7장 - 객체 분해"/><meta property="og:url" content="https://headf1rst.github.io/TIL/object7"/><meta property="og:type" content="blog"/><meta property="og:image" content="https://wikibook.co.kr/images/cover/m/9791158391409.png"/><meta property="og:description"/><meta name="next-head-count" content="22"/><link rel="preload" href="/TIL/_next/static/css/754b961274c075df.css" as="style"/><link rel="stylesheet" href="/TIL/_next/static/css/754b961274c075df.css" data-n-g=""/><link rel="preload" href="/TIL/_next/static/css/38994dd0aed51f22.css" as="style"/><link rel="stylesheet" href="/TIL/_next/static/css/38994dd0aed51f22.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/TIL/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/TIL/_next/static/chunks/webpack-ac557983bcc4c022.js" defer=""></script><script src="/TIL/_next/static/chunks/framework-2c79e2a64abdb08b.js" defer=""></script><script src="/TIL/_next/static/chunks/main-dc8c1543918dad35.js" defer=""></script><script src="/TIL/_next/static/chunks/pages/_app-421e211a78340d83.js" defer=""></script><script src="/TIL/_next/static/chunks/202-7f08bae5ecc79443.js" defer=""></script><script src="/TIL/_next/static/chunks/pages/%5Bid%5D-e822cf87f2ef122d.js" defer=""></script><script src="/TIL/_next/static/DgHcyLVbQaP3fKIpTojx6/_buildManifest.js" defer=""></script><script src="/TIL/_next/static/DgHcyLVbQaP3fKIpTojx6/_ssgManifest.js" defer=""></script></head><body><div id="__next"><nav class="flex bg-white sticky top-0 left-0 z-50 justify-between items-center border-b-2 border-gray-100 py-3 md:justify-start md:space-x-10 px-10 sm:px-5 dark:bg-[#0d1117] dark:text-[#c9d1d9] dark:border-gray-600"><div class="flex justify-start"><a href="/TIL"><div class="flex items-center gap-2 cursor-pointer"><img src="https://i.imgur.com/2nHGFTv.png" width="40" height="40" alt="블로그 아이콘"/><h1 class="text-lg ">산하개발실록</h1></div></a></div><div class="flex justify-between gap-10 sm:hidden"><a href="/TIL"><button class="font-light hover:text-indigo-300 text-base">Home</button></a><a href="/TIL/category"><button class="font-light hover:text-indigo-300 text-base">Category</button></a><a href="https://plain-composer-c65.notion.site/29c7640fdf054059b6ea28ed61189bfb" target="_blank" rel="noreferrer" class="hover:text-indigo-300 text-base font-light flex gap-1">About<span class="flex justify-center" style="align-items:center"><svg stroke="currentColor" fill="currentColor" stroke-width="0" viewBox="0 0 24 24" height="1em" width="1em" xmlns="http://www.w3.org/2000/svg"><path d="m13 3 3.293 3.293-7 7 1.414 1.414 7-7L21 11V3z"></path><path d="M19 19H5V5h7l-2-2H5c-1.103 0-2 .897-2 2v14c0 1.103.897 2 2 2h14c1.103 0 2-.897 2-2v-5l-2-2v7z"></path></svg></span></a></div><svg stroke="currentColor" fill="currentColor" stroke-width="0" viewBox="0 0 512 512" class="lg:hidden" height="25" width="25" xmlns="http://www.w3.org/2000/svg"><path d="M32 96v64h448V96H32zm0 128v64h448v-64H32zm0 128v64h448v-64H32z"></path></svg></nav><main class="dark:bg-[#0d1117] h-screen pb-10"><div class="flex flex-col w-3/5 sm:w-5/6 m-auto pt-20 pb-20 gap-10 dark:bg-[#0d1117] dark:text-[#c9d1d9]"><ul id="scroll-spy" class="sm:hidden p-10 fixed top-50 right-0 h-full w-1/5 text-gray-500 dark:text-[#c9d1d9]"></ul><div class="text-5xl font-bold">[오브젝트] 7장 - 객체 분해</div><div class="flex flex-col gap-2"><div class="text-base text-gray-600 dark:text-gray-300">2022-10-02 10:00</div><div class="flex flex-wrap gap-2 dark:text-black sm:m-0"><span class="p-1 pl-3 pr-3 rounded-md bg-indigo-100 hover:bg-indigo-200 cursor-pointer transition ease-in-out duration-200 text-sm">object</span></div></div><div class="markdown-body" style="font-size:17px"><p>모든 프로그래밍 패러다임은 추상화와 분해의 관점에서 설명 가능</p>
<h2>추상화 메커니즘</h2>
<p>시스템을 분해하는 방법을 프로시저와 데이터 추상화중 하나를 중심으로 하여 결정해야한다.</p>
<ul>
<li>
<ol>
<li>프로시저 추상화</li>
</ol>
<ul>
<li>소프트웨어가 무엇을 <strong>해야</strong>하는지 추상화</li>
<li>기능 분해<!-- -->
<ul>
<li>기능 구현을 위해 필요한 기능들을 순차적으로 찾아가는 탐색의 과정</li>
</ul>
</li>
</ul>
</li>
<li>
<ol start="2">
<li>데이터 추상화</li>
</ol>
<ul>
<li>소프트웨어가 무엇을 <strong>알아야</strong> 하는지 추상화</li>
<li>타입을 추상화(추상 데이터 타입) vs 프로시저를 추상화(객체지향)<!-- -->
<ul>
<li>타입을 추상화 하면 <code node="[object Object]">추상 데이터 타입</code></li>
<li>프로시저를 추상화 하면 <code node="[object Object]">객체지향</code></li>
</ul>
</li>
</ul>
</li>
</ul>
<h2>1. 프로시저 추상화와 기능 분해</h2>
<ul>
<li>프로시저<!-- -->
<ul>
<li>반복적으로 수행되는 작업을 한 장소에 모아서 로직을 재사용하고 중복을 방지하는 추상화 방법</li>
<li>내부의 상세 구현을 모르더라도 인터페이스만 알면 프로시저 사용 가능.</li>
<li>기능 분해 방식 - <strong>하향식 접근법</strong></li>
</ul>
</li>
</ul>
<h3>하향식 접근법</h3>
<p>최상위 기능을 정의하고(메인 함수) 덜 추상적인 하위 기능으로 분해해 나가는 방법</p>
<h4>하향식 접근법의 문제점</h4>
<ul>
<li>현대 시스템은 동등한 수준의 다양한 기능으로 구성된다.</li>
<li>대부분의 시스템은 하나의 메임 함수로 구성돼 있지 않다.<!-- -->
<ul>
<li>&quot;실제 시스템에 정상이란 존재하지 않는다&quot;</li>
</ul>
</li>
<li>요구사항 변경시 메인 함수를 빈번하게 변경해야 한다.</li>
<li>로직이 사용자 인터페이스와 강하게 결합되어있다.</li>
<li>데이터 형식이 변경될 경우 관련된 모든 함수를 수정해야한다.</li>
<li>설계 시작부터 시스템이 <strong>어떻게</strong> 동작해야 하는지에 집중하게 한다.</li>
<li>이른 시기에 함수 실행 순서를 고정하여 유연성과 재사용성이 떨어진다.</li>
</ul>
<p>이와 같은 기능 분해의 문제를 해결하기 위해 정보 은닉과 모듈 개념이 등장.</p>
<h2>모듈</h2>
<ul>
<li>변경의 방향에 맞춰 시스템을 분해하라</li>
<li>함께 변경되는 부분을 하나의 구현 단위(모듈)로 묶고 퍼블릭 인터페이스를 통해서만 접근 가능하도록 만드는 것. (높은 응집도, 낮은 결합도)</li>
<li>각 모듈은 외부에 감춰야 하는 비밀과 관련성 높은 데이터, 함수의 집합.</li>
</ul>
<h3>정보 은닉</h3>
<p>시스템을 모듈 단위로 분해하기 위한 기본 원리.</p>
<p>시스템에서 <strong>자주 변경되는 부분을</strong> 상대적으로 덜 변경되는 <strong>인터페이스 뒤로 감춰라.</strong></p>
<ul>
<li>모듈 분해<!-- -->
<ul>
<li>감춰야 하는 정보를 선택하고 정보를 안정적인 보호막(퍼블릭 인터페이스)을 통해 보존하는 과정</li>
<li>모듈 분해 후, 기능 분해를 통해서 모듈에 필요한 퍼블릭 인터페이스를 구현</li>
</ul>
</li>
</ul>
<h3>모듈의 장점과 한계</h3>
<h4>장점</h4>
<ul>
<li>모듈 데이터 변경으로 인한 파급효과를 제어할 수 있기 때문에 코드 수정 및 디버깅이 용이하다.</li>
<li>비즈니스 로직과 사용자 인터페이스에 대한 관심사가 분리된다.</li>
<li>전역 변수와 전역 함수를 제거하여 네임스페이스 오염을 방지한다.</li>
</ul>
<h4>단점</h4>
<ul>
<li>인스턴스의 개념을 제공하지 않는다.</li>
</ul>
<p>이러한 단점을 개선하기 위해 <code node="[object Object]">추상 데이터 타입</code>이라는 개념이 등장.</p>
<h2>2. 데이터 추상화</h2>
<h3>추상 데이터 타입</h3>
<ul>
<li>프로그래밍 언어가 제공하는 타입처럼 동작하는 <strong>사용자 정의 타입</strong></li>
<li>타입을 개발자가 정의할 수 있다.</li>
<li>하나의 물리적 타입 안에 개념적 타입에 대한 구현을 감춘다.</li>
</ul>
<h3>클래스는 추상 데이터 타입인가?</h3>
<h4>클래스와 추상 데이터 타입의 차이</h4>
<ul>
<li>
<p>클래스</p>
<ul>
<li>상속과 다형성을 지원 - 객체지향 프로그래밍</li>
<li>절차를 추상화 한것</li>
<li>타입을 기준으로 오퍼레이션을 묶는다.</li>
</ul>
</li>
<li>
<p>추상 데이터 타입</p>
<ul>
<li>상속과 다형성 지원 X - 객체기반 프로그래밍</li>
<li>타입을 추상화 한것</li>
<li>오퍼레이션을 기준으로 타입을 묶는다</li>
</ul>
</li>
<li>
<p>클래스가 추상 데이터 타입의 개념을 따르는지 확인하는 방법</p>
<ul>
<li>클래스 내부에 인스턴스의 타입을 표현하는 변수의 유무<!-- -->
<ul>
<li>인스턴스 변수에 저장된 값을 기반으로 메서드 내에서 타입을 명시적으로 구분하는건 객체지향을 위반</li>
</ul>
</li>
<li>타입을 기준으로 절차를 추상화하지 않았다면 객체지향 분해가 아니다.</li>
</ul>
</li>
</ul>
<h2>변경을 기준으로 선택하라</h2>
<p>설계의 유용성은 변경의 방향성과 발생 빈도에 따라 결정된다.</p>
<ul>
<li>클래스 구조를 선택하는 경우<!-- -->
<ul>
<li>타입 추가라는 변경의 압력이 더 강한 경우<!-- -->
<ul>
<li>새로운 타입을 빈번하게 추가해야 하는 경우</li>
</ul>
</li>
</ul>
</li>
<li>추상 데이터 타입을 선택하는 경우<!-- -->
<ul>
<li>변경의 주된 압력이 오퍼레이션 추가인 경우<!-- -->
<ul>
<li>새로운 오퍼레이션을 빈번하게 추가해야 하는 경우</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>변경의 축을 찾아야 한다.
객체지향적인 접근법이 은총알은 아니다.</p>
<h2>느낀점</h2>
<p>추상 데이터 타입이 사용된 예가 뭐가있을지 고민해 보았는데 스택과 같은 자료구조가 떠올랐다.</p>
<p>자료구조 수업에서 C++로 스택과 연결 리스트 등을 구현해 보았었는데, 이번 기회에 자바로도 한번 구현해 보도록 해야겠다.</p></div><section></section></div></main></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"postData":{"id":"object7","title":"[오브젝트] 7장 - 객체 분해","category":"object","thumbnail":"https://wikibook.co.kr/images/cover/m/9791158391409.png","tags":"object","date":"2022-10-02 10:00","preview":"\n모든 프로그래밍 패러다임은 추상화와 분해의 관점에서 설명 가능\n\n## 추상화 메커니즘\n시스템을 분해하는 방법을 프로시저와 데이터 추상화중 하나를 중심으로 하여 결정해야한다.\n\n- 1. 프로시저 추상화\n    - 소프트웨어가 무엇을 **해야**하는지 "},"detail":"\n모든 프로그래밍 패러다임은 추상화와 분해의 관점에서 설명 가능\n\n## 추상화 메커니즘\n시스템을 분해하는 방법을 프로시저와 데이터 추상화중 하나를 중심으로 하여 결정해야한다.\n\n- 1. 프로시저 추상화\n    - 소프트웨어가 무엇을 **해야**하는지 추상화\n    - 기능 분해\n        - 기능 구현을 위해 필요한 기능들을 순차적으로 찾아가는 탐색의 과정\n- 2. 데이터 추상화\n    - 소프트웨어가 무엇을 **알아야** 하는지 추상화\n    - 타입을 추상화(추상 데이터 타입) vs 프로시저를 추상화(객체지향)\n        - 타입을 추상화 하면 `추상 데이터 타입`\n        - 프로시저를 추상화 하면 `객체지향`\n\n## 1. 프로시저 추상화와 기능 분해\n\n- 프로시저\n    - 반복적으로 수행되는 작업을 한 장소에 모아서 로직을 재사용하고 중복을 방지하는 추상화 방법\n    - 내부의 상세 구현을 모르더라도 인터페이스만 알면 프로시저 사용 가능.\n    - 기능 분해 방식 - **하향식 접근법**\n\n### 하향식 접근법\n\n최상위 기능을 정의하고(메인 함수) 덜 추상적인 하위 기능으로 분해해 나가는 방법\n\n#### 하향식 접근법의 문제점\n\n- 현대 시스템은 동등한 수준의 다양한 기능으로 구성된다.\n- 대부분의 시스템은 하나의 메임 함수로 구성돼 있지 않다.\n    - \"실제 시스템에 정상이란 존재하지 않는다\"\n- 요구사항 변경시 메인 함수를 빈번하게 변경해야 한다.\n- 로직이 사용자 인터페이스와 강하게 결합되어있다.\n- 데이터 형식이 변경될 경우 관련된 모든 함수를 수정해야한다.\n- 설계 시작부터 시스템이 **어떻게** 동작해야 하는지에 집중하게 한다.\n- 이른 시기에 함수 실행 순서를 고정하여 유연성과 재사용성이 떨어진다.\n\n이와 같은 기능 분해의 문제를 해결하기 위해 정보 은닉과 모듈 개념이 등장.\n\n## 모듈\n\n- 변경의 방향에 맞춰 시스템을 분해하라\n- 함께 변경되는 부분을 하나의 구현 단위(모듈)로 묶고 퍼블릭 인터페이스를 통해서만 접근 가능하도록 만드는 것. (높은 응집도, 낮은 결합도)\n- 각 모듈은 외부에 감춰야 하는 비밀과 관련성 높은 데이터, 함수의 집합.\n\n### 정보 은닉\n\n시스템을 모듈 단위로 분해하기 위한 기본 원리.\n\n시스템에서 **자주 변경되는 부분을** 상대적으로 덜 변경되는 **인터페이스 뒤로 감춰라.**\n\n- 모듈 분해\n    - 감춰야 하는 정보를 선택하고 정보를 안정적인 보호막(퍼블릭 인터페이스)을 통해 보존하는 과정\n    - 모듈 분해 후, 기능 분해를 통해서 모듈에 필요한 퍼블릭 인터페이스를 구현\n\n### 모듈의 장점과 한계\n\n#### 장점\n\n- 모듈 데이터 변경으로 인한 파급효과를 제어할 수 있기 때문에 코드 수정 및 디버깅이 용이하다.\n- 비즈니스 로직과 사용자 인터페이스에 대한 관심사가 분리된다.\n- 전역 변수와 전역 함수를 제거하여 네임스페이스 오염을 방지한다.\n\n#### 단점\n\n- 인스턴스의 개념을 제공하지 않는다.\n\n이러한 단점을 개선하기 위해 `추상 데이터 타입`이라는 개념이 등장.\n\n## 2. 데이터 추상화\n\n### 추상 데이터 타입\n\n- 프로그래밍 언어가 제공하는 타입처럼 동작하는 **사용자 정의 타입**\n- 타입을 개발자가 정의할 수 있다.\n- 하나의 물리적 타입 안에 개념적 타입에 대한 구현을 감춘다.\n\n### 클래스는 추상 데이터 타입인가?\n\n#### 클래스와 추상 데이터 타입의 차이\n\n- 클래스\n    - 상속과 다형성을 지원 - 객체지향 프로그래밍\n    - 절차를 추상화 한것\n    - 타입을 기준으로 오퍼레이션을 묶는다.\n- 추상 데이터 타입\n    - 상속과 다형성 지원 X - 객체기반 프로그래밍\n    - 타입을 추상화 한것\n    - 오퍼레이션을 기준으로 타입을 묶는다\n\n- 클래스가 추상 데이터 타입의 개념을 따르는지 확인하는 방법\n    - 클래스 내부에 인스턴스의 타입을 표현하는 변수의 유무\n        - 인스턴스 변수에 저장된 값을 기반으로 메서드 내에서 타입을 명시적으로 구분하는건 객체지향을 위반\n    - 타입을 기준으로 절차를 추상화하지 않았다면 객체지향 분해가 아니다.\n\n## 변경을 기준으로 선택하라\n\n설계의 유용성은 변경의 방향성과 발생 빈도에 따라 결정된다.\n\n- 클래스 구조를 선택하는 경우\n    - 타입 추가라는 변경의 압력이 더 강한 경우\n        - 새로운 타입을 빈번하게 추가해야 하는 경우\n- 추상 데이터 타입을 선택하는 경우\n    - 변경의 주된 압력이 오퍼레이션 추가인 경우\n        - 새로운 오퍼레이션을 빈번하게 추가해야 하는 경우\n\n변경의 축을 찾아야 한다.\n객체지향적인 접근법이 은총알은 아니다.\n\n## 느낀점\n\n추상 데이터 타입이 사용된 예가 뭐가있을지 고민해 보았는데 스택과 같은 자료구조가 떠올랐다.\n\n자료구조 수업에서 C++로 스택과 연결 리스트 등을 구현해 보았었는데, 이번 기회에 자바로도 한번 구현해 보도록 해야겠다.\n"},"__N_SSG":true},"page":"/[id]","query":{"id":"object7"},"buildId":"DgHcyLVbQaP3fKIpTojx6","assetPrefix":"/TIL","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>