<!DOCTYPE html><html><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><link rel="apple-touch-icon" sizes="180x180" href="https://i.imgur.com/2nHGFTv.png"/><link rel="icon" type="image/png" sizes="32x32" href="https://i.imgur.com/2nHGFTv.png"/><link rel="icon" type="image/png" sizes="16x16" href="https://i.imgur.com/2nHGFTv.png"/><link rel="manifest" href="/site.webmanifest"/><link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5"/><meta name="msapplication-TileColor" content="#da532c"/><meta name="theme-color" content="#ffffff"/><title>Gson 라이브러리 InaccessibleObjectException</title><meta name="title" content="Gson 라이브러리 InaccessibleObjectException"/><meta name="description" content="gson"/><meta name="keywords" content="gson, java"/><meta name="robots" content="index, follow"/><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><meta name="language" content="Korean"/><meta name="author" content="Sanha Ko"/><meta property="og:title" content="Gson 라이브러리 InaccessibleObjectException"/><meta property="og:url" content="https://headf1rst.github.io/TIL/post-1-4"/><meta property="og:type" content="blog"/><meta property="og:image" content="https://media.techmaster.vn/api/static/bq0a8rs51co78aldi4p0/lsRpW5hr"/><meta property="og:description" content="gson"/><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","headline":"Gson 라이브러리 InaccessibleObjectException","datePublished":"2024-07-02 10:00","dateModified":"2024-07-02 10:00","author":{"@type":"Person","name":"Sanha Ko"},"description":"gson","image":"https://media.techmaster.vn/api/static/bq0a8rs51co78aldi4p0/lsRpW5hr","url":"https://headf1rst.github.io/TIL/post-1-4","keywords":"gson,java","publisher":{"@type":"Organization","name":"headF1rst","logo":{"@type":"ImageObject","url":"https://headf1rst.github.io/TIL/favicon.ico"}},"mainEntityOfPage":{"@type":"WebPage","@id":"https://headf1rst.github.io/TIL/post-1-4"}}</script><meta name="next-head-count" content="23"/><link rel="preload" href="/TIL/_next/static/css/754b961274c075df.css" as="style"/><link rel="stylesheet" href="/TIL/_next/static/css/754b961274c075df.css" data-n-g=""/><link rel="preload" href="/TIL/_next/static/css/38994dd0aed51f22.css" as="style"/><link rel="stylesheet" href="/TIL/_next/static/css/38994dd0aed51f22.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/TIL/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/TIL/_next/static/chunks/webpack-ac557983bcc4c022.js" defer=""></script><script src="/TIL/_next/static/chunks/framework-2c79e2a64abdb08b.js" defer=""></script><script src="/TIL/_next/static/chunks/main-dc8c1543918dad35.js" defer=""></script><script src="/TIL/_next/static/chunks/pages/_app-421e211a78340d83.js" defer=""></script><script src="/TIL/_next/static/chunks/202-7f08bae5ecc79443.js" defer=""></script><script src="/TIL/_next/static/chunks/pages/%5Bid%5D-a17d958fe22e8c91.js" defer=""></script><script src="/TIL/_next/static/rHHwQgn4XzsFFzcKqsKPc/_buildManifest.js" defer=""></script><script src="/TIL/_next/static/rHHwQgn4XzsFFzcKqsKPc/_ssgManifest.js" defer=""></script></head><body><div id="__next"><nav class="flex bg-white sticky top-0 left-0 z-50 justify-between items-center border-b-2 border-gray-100 py-3 md:justify-start md:space-x-10 px-10 sm:px-5 dark:bg-[#0d1117] dark:text-[#c9d1d9] dark:border-gray-600"><div class="flex justify-start"><a href="/TIL"><div class="flex items-center gap-2 cursor-pointer"><img src="https://i.imgur.com/2nHGFTv.png" width="40" height="40" alt="블로그 아이콘"/><h1 class="text-lg ">산하개발실록</h1></div></a></div><div class="flex justify-between gap-10 sm:hidden"><a href="/TIL"><button class="font-light hover:text-indigo-300 text-base">Home</button></a><a href="/TIL/category"><button class="font-light hover:text-indigo-300 text-base">Category</button></a><a href="https://plain-composer-c65.notion.site/29c7640fdf054059b6ea28ed61189bfb" target="_blank" rel="noreferrer" class="hover:text-indigo-300 text-base font-light flex gap-1">About<span class="flex justify-center" style="align-items:center"><svg stroke="currentColor" fill="currentColor" stroke-width="0" viewBox="0 0 24 24" height="1em" width="1em" xmlns="http://www.w3.org/2000/svg"><path d="m13 3 3.293 3.293-7 7 1.414 1.414 7-7L21 11V3z"></path><path d="M19 19H5V5h7l-2-2H5c-1.103 0-2 .897-2 2v14c0 1.103.897 2 2 2h14c1.103 0 2-.897 2-2v-5l-2-2v7z"></path></svg></span></a></div><svg stroke="currentColor" fill="currentColor" stroke-width="0" viewBox="0 0 512 512" class="lg:hidden" height="25" width="25" xmlns="http://www.w3.org/2000/svg"><path d="M32 96v64h448V96H32zm0 128v64h448v-64H32zm0 128v64h448v-64H32z"></path></svg></nav><main class="dark:bg-[#0d1117] h-screen pb-10"><div class="flex flex-col w-3/5 sm:w-5/6 m-auto pt-20 pb-20 gap-10 dark:bg-[#0d1117] dark:text-[#c9d1d9]"><ul id="scroll-spy" class="sm:hidden p-10 fixed top-50 right-0 h-full w-1/5 text-gray-500 dark:text-[#c9d1d9]"></ul><div class="text-5xl font-bold">Gson 라이브러리 InaccessibleObjectException</div><div class="flex flex-col gap-2"><div class="text-base text-gray-600 dark:text-gray-300">2024-07-02 10:00</div><div class="flex flex-wrap gap-2 dark:text-black sm:m-0"><span class="p-1 pl-3 pr-3 rounded-md bg-indigo-100 hover:bg-indigo-200 cursor-pointer transition ease-in-out duration-200 text-sm">gson</span><span class="p-1 pl-3 pr-3 rounded-md bg-indigo-100 hover:bg-indigo-200 cursor-pointer transition ease-in-out duration-200 text-sm">java</span></div></div><div class="markdown-body" style="font-size:17px"><p>Spring Boot 2.5.x 버전에서 3.2.x 버전으로 마이그레이션 하는 과정에서 InaccessibleObjectException이 발생하였다. Gson 라이브러리를 사용하는 쪽에서 발생한 문제였는데, 이에 대한 트러블 슈팅 과정을 정리해 보고자 한다.</p>
<h2>Gson 라이브러리 란?</h2>
<p>구글이 만든 자바 기반 라이브러리로, 자바 객체를 JSON으로 직렬화(Serialization)하거나 JSON을 자바 객체로 역직렬화(Deserialization)하는 작업을 쉽게 할 수 있도록 도와준다.</p>
<h3>직렬화 과정 내부 동작</h3>
<p><code node="[object Object]">Gson.toJson(Object)</code> 메서드는 객체를 전달받아, 인자로 전달된 객체를 Json으로 변환하여 반환한다.</p>
<pre><div node="[object Object]" style="display:block;overflow-x:auto;padding:0.5em;color:#383a42;background:#fafafa"><code class="language-java" style="white-space:pre"><span>Gson gson = </span><span style="color:#a626a4">new</span><span> Gson();
</span>String json = gson.toJson(myObject);</code></div></pre>
<p><code node="[object Object]">toJson(Object src)</code> 메서드는 내부적으로 객체의 타입을 추론한 후 <code node="[object Object]">toJson(Object src, Type typeOfSrc, Appendable writer)</code> 메서드를 호출한다.</p>
<p>호출된 <code node="[object Object]">toJson</code> 메서드는 주어진 객체 타입에 맞는 <code node="[object Object]">TypeAdapter</code>를 찾고, 이를 사용하여 객체를 JSON으로 변환한다. 이때 객체 타입에 맞는 TypeAdapter를 찾기 위해 <code node="[object Object]">getAdapter(TypeToken)</code> 메서드를 호출한다.</p>
<pre><div node="[object Object]" style="display:block;overflow-x:auto;padding:0.5em;color:#383a42;background:#fafafa"><code class="language-java" style="white-space:pre"><span class="hljs-function" style="color:#a626a4">public</span><span class="hljs-function"> </span><span class="hljs-function" style="color:#a626a4">void</span><span class="hljs-function"> </span><span class="hljs-function" style="color:#4078f2">toJson</span><span class="hljs-function hljs-params">(Object src, Type typeOfSrc, JsonWriter writer)</span><span class="hljs-function"> </span><span class="hljs-function" style="color:#a626a4">throws</span><span class="hljs-function"> JsonIOException </span><span>{  
</span>    TypeAdapter&lt;Object&gt; adapter = (TypeAdapter&lt;Object&gt;) getAdapter(TypeToken.get(typeOfSrc));
<span>    </span><span style="color:#a0a1a7;font-style:italic">// ...</span><span>
</span>}</code></div></pre>
<p><code node="[object Object]">getAdapter(TypeToken)</code> 메서드는 주어진 타입에 대한 <code node="[object Object]">TypeAdapter</code>를 먼저 캐시에서 찾고, 없으면 <code node="[object Object]">TypeAdapterFactory</code> 리스트를 순회하면서 각 팩토리에 대해 <code node="[object Object]">create</code> 메서드를 호출하여 주어진 타입에 대한 <code node="[object Object]">TypeAdapter</code>를 생성할 수 있는지 확인한다.</p>
<pre><div node="[object Object]" style="display:block;overflow-x:auto;padding:0.5em;color:#383a42;background:#fafafa"><code class="language-java" style="white-space:pre"><span style="color:#a626a4">public</span><span> &lt;T&gt; </span><span class="hljs-function">TypeAdapter&lt;T&gt; </span><span class="hljs-function" style="color:#4078f2">getAdapter</span><span class="hljs-function hljs-params">(TypeToken&lt;T&gt; type)</span><span class="hljs-function"> </span><span>{  
</span>  TypeAdapter&lt;?&gt; cached = typeTokenCache.get(type);  
<span>  </span><span style="color:#a626a4">if</span><span> (cached != </span><span style="color:#a626a4">null</span><span>) {  
</span>    TypeAdapter&lt;T&gt; adapter = (TypeAdapter&lt;T&gt;) cached;  
<span>    </span><span style="color:#a626a4">return</span><span> adapter;  
</span>  }  
<!-- -->
<span>  </span><span style="color:#a0a1a7;font-style:italic">// ...</span><span>
</span>  
<span>  TypeAdapter&lt;T&gt; candidate = </span><span style="color:#a626a4">null</span><span>;  
</span><span>  </span><span style="color:#a626a4">try</span><span> {  
</span><span>    FutureTypeAdapter&lt;T&gt; call = </span><span style="color:#a626a4">new</span><span> FutureTypeAdapter&lt;&gt;();  
</span>    threadCalls.put(type, call);  
<!-- -->  
<span>    </span><span style="color:#a626a4">for</span><span> (TypeAdapterFactory factory : factories) {  
</span><span>      candidate = factory.create(</span><span style="color:#a626a4">this</span><span>, type);  
</span><span>      </span><span style="color:#a626a4">if</span><span> (candidate != </span><span style="color:#a626a4">null</span><span>) {  
</span>        call.setDelegate(candidate);  
<span>        </span><span style="color:#a0a1a7;font-style:italic">// Replace future adapter with actual adapter  </span><span>
</span>        threadCalls.put(type, candidate);  
<span>        </span><span style="color:#a626a4">break</span><span>;  
</span>      }  
<!-- -->    }  
<!-- -->  } 
<span>  </span><span style="color:#a0a1a7;font-style:italic">// ...</span><span>
</span><span>  </span><span style="color:#a626a4">return</span><span> candidate;  
</span>}</code></div></pre>
<p>TypeAdapterFactory 리스트를 순회하면서, 먼저 사용자 정의 또는 특수한 TypeAdapterFactory를 확인하고, 적절한 TypeAdapter를 찾지 못하면 <strong>ReflectiveTypeAdapterFactory</strong>를 사용하여 객체의 필드에 접근하고 JSON으로 직렬화 한다.</p>
<h2>문제 원인</h2>
<blockquote>
<p>Unable to make field private final java.time.LocalDate java.time.LocalDateTime.date accessible: module java.base does not &quot;opens java.time&quot; to unnamed module.</p>
</blockquote>
<p>로그인 시에 <code node="[object Object]">ValidToken</code> 객체를 직렬화하여 Redis에 저장하는 과정에서 Gson 라이브러리를 사용하는데, 위와 같은 예외가 발생했다.</p>
<p>Spring Boot 3.2.x로 버전업하면서 Java 버전 또한 11에서 17로 업그레이드 하였다.
Java 17 이상 부터는 모듈화된 애플리케이션에서 리플렉션을 통해 다른 모듈의 private 필드에 접근하는 것이 제한되도록 변경 되었기 때문에, Gson 라이브러리를 사용하여 TypeAdapterFactory 리스트를 순회하는 과정에서 문제가 발생하는것 이었다.</p>
<p>Gson은 먼저 사용자 정의 또는 특수한 <code node="[object Object]">TypeAdapterFactory</code>를 확인하고, 적절한 <code node="[object Object]">TypeAdapter</code>를 찾지 못하면 <code node="[object Object]">ReflectiveTypeAdapterFactory</code>를 사용하게 된다.</p>
<p><code node="[object Object]">ReflectiveTypeAdapterFactory</code>는 객체의 필드를 탐색하고, <code node="[object Object]">field.setAccessible(true)</code>를 호출하여 private 필드를 접근 가능하도록 설정한다. 하지만 Java 17 이상의 모듈 시스템에서는 모듈화된
애플리케이션에서 이러한 호출이 기본적으로 제한되기 때문에 <code node="[object Object]">ReflectiveTypeAdapterFactory</code>가 private 필드에 접근할 수 없게 되어, 결과적으로 직렬화 및 역직렬화 과정에서 예외가 발생하게 되는 것이다.</p>
<h2>해결방법</h2>
<p>private 필드를 가진 클래스 타입에 대한 직렬화 및 역직렬화 로직이 구현된 커스텀 TypeAdapter를 구현한면 Gson이 TypeAdapterFactory 리스트를 순회할 때, 정의한 커스텀 TypeAdapter가 ReflectiveTypeAdapterFactory 보다 우선순위를 갖기 때문에 문제를 해결할 수 있다.</p>
<pre><div node="[object Object]" style="display:block;overflow-x:auto;padding:0.5em;color:#383a42;background:#fafafa"><code class="language-java" style="white-space:pre"><span style="color:#a626a4">public</span><span> </span><span class="hljs-class" style="color:#a626a4">class</span><span class="hljs-class"> </span><span class="hljs-class" style="color:#4078f2">LocalDateTimeAdapter</span><span class="hljs-class"> </span><span class="hljs-class" style="color:#a626a4">extends</span><span class="hljs-class"> </span><span class="hljs-class" style="color:#4078f2">TypeAdapter</span><span class="hljs-class">&lt;</span><span class="hljs-class" style="color:#4078f2">LocalDateTime</span><span class="hljs-class">&gt; </span><span>{
</span>
<span>    </span><span style="color:#a626a4">private</span><span> </span><span style="color:#a626a4">static</span><span> </span><span style="color:#a626a4">final</span><span> DateTimeFormatter formatter = DateTimeFormatter.ISO_LOCAL_DATE_TIME;
</span>
<span>    </span><span style="color:#4078f2">@Override</span><span>
</span><span>    </span><span class="hljs-function" style="color:#a626a4">public</span><span class="hljs-function"> </span><span class="hljs-function" style="color:#a626a4">void</span><span class="hljs-function"> </span><span class="hljs-function" style="color:#4078f2">write</span><span class="hljs-function hljs-params">(JsonWriter jsonWriter, LocalDateTime localDateTime)</span><span class="hljs-function"> </span><span class="hljs-function" style="color:#a626a4">throws</span><span class="hljs-function"> IOException </span><span>{
</span>        jsonWriter.value(localDateTime.format(formatter));
<!-- -->    }
<!-- -->
<span>    </span><span style="color:#4078f2">@Override</span><span>
</span><span>    </span><span class="hljs-function" style="color:#a626a4">public</span><span class="hljs-function"> LocalDateTime </span><span class="hljs-function" style="color:#4078f2">read</span><span class="hljs-function hljs-params">(JsonReader jsonReader)</span><span class="hljs-function"> </span><span class="hljs-function" style="color:#a626a4">throws</span><span class="hljs-function"> IOException </span><span>{
</span><span>        </span><span style="color:#a626a4">return</span><span> LocalDateTime.parse(jsonReader.nextString(), formatter);
</span>    }
<!-- -->}</code></div></pre>
<h2>참고 자료</h2>
<ul>
<li><a href="https://github.com/google/gson/issues/1979">Error reflection JDK 17 and gson</a></li>
<li><a href="https://github.com/google/gson/blob/main/Troubleshooting.md#reflection-inaccessible">Gson 공식 트러블 슈팅 가이드 문서</a></li>
</ul></div><section></section></div></main></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"postData":{"id":"post-1-4","title":"Gson 라이브러리 InaccessibleObjectException","category":"java","thumbnail":"https://media.techmaster.vn/api/static/bq0a8rs51co78aldi4p0/lsRpW5hr","tags":"gson, java","date":"2024-07-02 10:00","searchKeywords":"gson, java","description":"gson","preview":"\nSpring Boot 2.5.x 버전에서 3.2.x 버전으로 마이그레이션 하는 과정에서 InaccessibleObjectException이 발생하였다. Gson 라이브러리를 사용하는 쪽에서 발생한 문제였는데, 이에 대한 트러블 슈팅 과정을 정리해 보"},"detail":"\nSpring Boot 2.5.x 버전에서 3.2.x 버전으로 마이그레이션 하는 과정에서 InaccessibleObjectException이 발생하였다. Gson 라이브러리를 사용하는 쪽에서 발생한 문제였는데, 이에 대한 트러블 슈팅 과정을 정리해 보고자 한다.\n\n## Gson 라이브러리 란?\n\n구글이 만든 자바 기반 라이브러리로, 자바 객체를 JSON으로 직렬화(Serialization)하거나 JSON을 자바 객체로 역직렬화(Deserialization)하는 작업을 쉽게 할 수 있도록 도와준다.\n\n### 직렬화 과정 내부 동작\n\n`Gson.toJson(Object)` 메서드는 객체를 전달받아, 인자로 전달된 객체를 Json으로 변환하여 반환한다.\n\n```java\nGson gson = new Gson();\nString json = gson.toJson(myObject);\n```\n\n`toJson(Object src)` 메서드는 내부적으로 객체의 타입을 추론한 후 `toJson(Object src, Type typeOfSrc, Appendable writer)` 메서드를 호출한다.\n\n호출된 `toJson` 메서드는 주어진 객체 타입에 맞는 `TypeAdapter`를 찾고, 이를 사용하여 객체를 JSON으로 변환한다. 이때 객체 타입에 맞는 TypeAdapter를 찾기 위해 `getAdapter(TypeToken)` 메서드를 호출한다.\n\n```java\npublic void toJson(Object src, Type typeOfSrc, JsonWriter writer) throws JsonIOException {  \n    TypeAdapter\u003cObject\u003e adapter = (TypeAdapter\u003cObject\u003e) getAdapter(TypeToken.get(typeOfSrc));\n    // ...\n}\n```\n\n`getAdapter(TypeToken)` 메서드는 주어진 타입에 대한 `TypeAdapter`를 먼저 캐시에서 찾고, 없으면 `TypeAdapterFactory` 리스트를 순회하면서 각 팩토리에 대해 `create` 메서드를 호출하여 주어진 타입에 대한 `TypeAdapter`를 생성할 수 있는지 확인한다.\n\n```java\npublic \u003cT\u003e TypeAdapter\u003cT\u003e getAdapter(TypeToken\u003cT\u003e type) {  \n  TypeAdapter\u003c?\u003e cached = typeTokenCache.get(type);  \n  if (cached != null) {  \n    TypeAdapter\u003cT\u003e adapter = (TypeAdapter\u003cT\u003e) cached;  \n    return adapter;  \n  }  \n\n  // ...\n  \n  TypeAdapter\u003cT\u003e candidate = null;  \n  try {  \n    FutureTypeAdapter\u003cT\u003e call = new FutureTypeAdapter\u003c\u003e();  \n    threadCalls.put(type, call);  \n  \n    for (TypeAdapterFactory factory : factories) {  \n      candidate = factory.create(this, type);  \n      if (candidate != null) {  \n        call.setDelegate(candidate);  \n        // Replace future adapter with actual adapter  \n        threadCalls.put(type, candidate);  \n        break;  \n      }  \n    }  \n  } \n  // ...\n  return candidate;  \n}\n```\n\nTypeAdapterFactory 리스트를 순회하면서, 먼저 사용자 정의 또는 특수한 TypeAdapterFactory를 확인하고, 적절한 TypeAdapter를 찾지 못하면 **ReflectiveTypeAdapterFactory**를 사용하여 객체의 필드에 접근하고 JSON으로 직렬화 한다.\n\n## 문제 원인\n\n\u003e Unable to make field private final java.time.LocalDate java.time.LocalDateTime.date accessible: module java.base does not \"opens java.time\" to unnamed module.\n\n로그인 시에 `ValidToken` 객체를 직렬화하여 Redis에 저장하는 과정에서 Gson 라이브러리를 사용하는데, 위와 같은 예외가 발생했다.\n\nSpring Boot 3.2.x로 버전업하면서 Java 버전 또한 11에서 17로 업그레이드 하였다.\nJava 17 이상 부터는 모듈화된 애플리케이션에서 리플렉션을 통해 다른 모듈의 private 필드에 접근하는 것이 제한되도록 변경 되었기 때문에, Gson 라이브러리를 사용하여 TypeAdapterFactory 리스트를 순회하는 과정에서 문제가 발생하는것 이었다.\n\nGson은 먼저 사용자 정의 또는 특수한 `TypeAdapterFactory`를 확인하고, 적절한 `TypeAdapter`를 찾지 못하면 `ReflectiveTypeAdapterFactory`를 사용하게 된다.\n\n`ReflectiveTypeAdapterFactory`는 객체의 필드를 탐색하고, `field.setAccessible(true)`를 호출하여 private 필드를 접근 가능하도록 설정한다. 하지만 Java 17 이상의 모듈 시스템에서는 모듈화된 \n애플리케이션에서 이러한 호출이 기본적으로 제한되기 때문에 `ReflectiveTypeAdapterFactory`가 private 필드에 접근할 수 없게 되어, 결과적으로 직렬화 및 역직렬화 과정에서 예외가 발생하게 되는 것이다.\n\n## 해결방법\n\nprivate 필드를 가진 클래스 타입에 대한 직렬화 및 역직렬화 로직이 구현된 커스텀 TypeAdapter를 구현한면 Gson이 TypeAdapterFactory 리스트를 순회할 때, 정의한 커스텀 TypeAdapter가 ReflectiveTypeAdapterFactory 보다 우선순위를 갖기 때문에 문제를 해결할 수 있다.\n\n```java\npublic class LocalDateTimeAdapter extends TypeAdapter\u003cLocalDateTime\u003e {\n\n    private static final DateTimeFormatter formatter = DateTimeFormatter.ISO_LOCAL_DATE_TIME;\n\n    @Override\n    public void write(JsonWriter jsonWriter, LocalDateTime localDateTime) throws IOException {\n        jsonWriter.value(localDateTime.format(formatter));\n    }\n\n    @Override\n    public LocalDateTime read(JsonReader jsonReader) throws IOException {\n        return LocalDateTime.parse(jsonReader.nextString(), formatter);\n    }\n}\n```\n\n## 참고 자료\n- [Error reflection JDK 17 and gson](https://github.com/google/gson/issues/1979)\n- [Gson 공식 트러블 슈팅 가이드 문서](https://github.com/google/gson/blob/main/Troubleshooting.md#reflection-inaccessible)\n"},"__N_SSG":true},"page":"/[id]","query":{"id":"post-1-4"},"buildId":"rHHwQgn4XzsFFzcKqsKPc","assetPrefix":"/TIL","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>