<!DOCTYPE html><html><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><link rel="apple-touch-icon" sizes="180x180" href="https://i.imgur.com/2nHGFTv.png"/><link rel="icon" type="image/png" sizes="32x32" href="https://i.imgur.com/2nHGFTv.png"/><link rel="icon" type="image/png" sizes="16x16" href="https://i.imgur.com/2nHGFTv.png"/><link rel="manifest" href="/site.webmanifest"/><link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5"/><meta name="msapplication-TileColor" content="#da532c"/><meta name="theme-color" content="#ffffff"/><title>JPA 트랜잭션과 영속성 컨텍스트</title><meta name="title" content="JPA 트랜잭션과 영속성 컨텍스트"/><meta name="description" content="JPA 트랜잭션과 영속성 컨텍스트"/><meta name="keywords" content="jpa, entitymanager, 영속성 컨텍스트, 트랜잭션"/><meta name="robots" content="index, follow"/><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><meta name="language" content="Korean"/><meta name="author" content="Sanha Ko"/><meta property="og:title" content="JPA 트랜잭션과 영속성 컨텍스트"/><meta property="og:url" content="https://headf1rst.github.io/TIL/post2-2"/><meta property="og:type" content="blog"/><meta property="og:image" content="https://images.velog.io/images/dnjscksdn98/post/14072bd8-850b-4d2b-8476-cb5385bbcd36/jpa.png"/><meta property="og:description" content="JPA 트랜잭션과 영속성 컨텍스트"/><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","headline":"JPA 트랜잭션과 영속성 컨텍스트","datePublished":"2024-01-07 10:00","dateModified":"2024-01-07 10:00","author":{"@type":"Person","name":"Sanha Ko"},"description":"JPA 트랜잭션과 영속성 컨텍스트","image":"https://images.velog.io/images/dnjscksdn98/post/14072bd8-850b-4d2b-8476-cb5385bbcd36/jpa.png","url":"https://headf1rst.github.io/TIL/post2-2","keywords":"JPA","publisher":{"@type":"Organization","name":"headF1rst","logo":{"@type":"ImageObject","url":"https://headf1rst.github.io/TIL/favicon.ico"}},"mainEntityOfPage":{"@type":"WebPage","@id":"https://headf1rst.github.io/TIL/post2-2"}}</script><meta name="next-head-count" content="23"/><link rel="preload" href="/TIL/_next/static/css/754b961274c075df.css" as="style"/><link rel="stylesheet" href="/TIL/_next/static/css/754b961274c075df.css" data-n-g=""/><link rel="preload" href="/TIL/_next/static/css/38994dd0aed51f22.css" as="style"/><link rel="stylesheet" href="/TIL/_next/static/css/38994dd0aed51f22.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/TIL/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/TIL/_next/static/chunks/webpack-ac557983bcc4c022.js" defer=""></script><script src="/TIL/_next/static/chunks/framework-2c79e2a64abdb08b.js" defer=""></script><script src="/TIL/_next/static/chunks/main-dc8c1543918dad35.js" defer=""></script><script src="/TIL/_next/static/chunks/pages/_app-421e211a78340d83.js" defer=""></script><script src="/TIL/_next/static/chunks/202-7f08bae5ecc79443.js" defer=""></script><script src="/TIL/_next/static/chunks/pages/%5Bid%5D-a17d958fe22e8c91.js" defer=""></script><script src="/TIL/_next/static/rHHwQgn4XzsFFzcKqsKPc/_buildManifest.js" defer=""></script><script src="/TIL/_next/static/rHHwQgn4XzsFFzcKqsKPc/_ssgManifest.js" defer=""></script></head><body><div id="__next"><nav class="flex bg-white sticky top-0 left-0 z-50 justify-between items-center border-b-2 border-gray-100 py-3 md:justify-start md:space-x-10 px-10 sm:px-5 dark:bg-[#0d1117] dark:text-[#c9d1d9] dark:border-gray-600"><div class="flex justify-start"><a href="/TIL"><div class="flex items-center gap-2 cursor-pointer"><img src="https://i.imgur.com/2nHGFTv.png" width="40" height="40" alt="블로그 아이콘"/><h1 class="text-lg ">산하개발실록</h1></div></a></div><div class="flex justify-between gap-10 sm:hidden"><a href="/TIL"><button class="font-light hover:text-indigo-300 text-base">Home</button></a><a href="/TIL/category"><button class="font-light hover:text-indigo-300 text-base">Category</button></a><a href="https://plain-composer-c65.notion.site/29c7640fdf054059b6ea28ed61189bfb" target="_blank" rel="noreferrer" class="hover:text-indigo-300 text-base font-light flex gap-1">About<span class="flex justify-center" style="align-items:center"><svg stroke="currentColor" fill="currentColor" stroke-width="0" viewBox="0 0 24 24" height="1em" width="1em" xmlns="http://www.w3.org/2000/svg"><path d="m13 3 3.293 3.293-7 7 1.414 1.414 7-7L21 11V3z"></path><path d="M19 19H5V5h7l-2-2H5c-1.103 0-2 .897-2 2v14c0 1.103.897 2 2 2h14c1.103 0 2-.897 2-2v-5l-2-2v7z"></path></svg></span></a></div><svg stroke="currentColor" fill="currentColor" stroke-width="0" viewBox="0 0 512 512" class="lg:hidden" height="25" width="25" xmlns="http://www.w3.org/2000/svg"><path d="M32 96v64h448V96H32zm0 128v64h448v-64H32zm0 128v64h448v-64H32z"></path></svg></nav><main class="dark:bg-[#0d1117] h-screen pb-10"><div class="flex flex-col w-3/5 sm:w-5/6 m-auto pt-20 pb-20 gap-10 dark:bg-[#0d1117] dark:text-[#c9d1d9]"><ul id="scroll-spy" class="sm:hidden p-10 fixed top-50 right-0 h-full w-1/5 text-gray-500 dark:text-[#c9d1d9]"></ul><div class="text-5xl font-bold">JPA 트랜잭션과 영속성 컨텍스트</div><div class="flex flex-col gap-2"><div class="text-base text-gray-600 dark:text-gray-300">2024-01-07 10:00</div><div class="flex flex-wrap gap-2 dark:text-black sm:m-0"><span class="p-1 pl-3 pr-3 rounded-md bg-indigo-100 hover:bg-indigo-200 cursor-pointer transition ease-in-out duration-200 text-sm">JPA</span></div></div><div class="markdown-body" style="font-size:17px"><p>최근 구현한 테스트 코드에서 <code node="[object Object]">@Transactional</code> 여부에 따라 테스트 결과가 달라지는 문제를 만나게 되었다.</p>
<p>타 서비스로부터 송장 접수 결과에 대한 카프카 메세지를 소비한 다음, 송장 접수에 실패했다면 택배 등록 여부를 실패로 변경하는 로직에 대한 테스트 코드였는데 당시 상황을 간단하게 재현해 보았다.</p>
<pre><div node="[object Object]" style="display:block;overflow-x:auto;padding:0.5em;color:#383a42;background:#fafafa"><code class="language-kotlin" style="white-space:pre"><span style="color:#4078f2">@Entity</span><span>  
</span><span></span><span style="color:#4078f2">@Table(name = </span><span style="color:#50a14f">&quot;orders&quot;</span><span style="color:#4078f2">)</span><span>  
</span><span></span><span class="hljs-class" style="color:#a626a4">class</span><span class="hljs-class"> </span><span class="hljs-class" style="color:#4078f2">Order</span><span class="hljs-class"> </span><span>(  
</span><span>    </span><span style="color:#a626a4">val</span><span> shippingLabel: String,  
</span><span>    </span><span style="color:#a626a4">var</span><span> parcelStatus: </span><span style="color:#c18401">Boolean</span><span> = </span><span style="color:#0184bb">true</span><span>,  
</span>  
<span>    </span><span style="color:#4078f2">@Id</span><span>  
</span><span>    </span><span style="color:#4078f2">@GeneratedValue(strategy = GenerationType.IDENTITY)</span><span>  
</span><span>    </span><span style="color:#a626a4">val</span><span> id: </span><span style="color:#c18401">Long</span><span>? = </span><span style="color:#0184bb">null</span><span>,  
</span>) {  
<span>    </span><span class="hljs-function" style="color:#a626a4">fun</span><span class="hljs-function"> </span><span class="hljs-function" style="color:#4078f2">isParcelRegister</span><span class="hljs-function hljs-params">()</span><span>: </span><span style="color:#c18401">Boolean</span><span> {  
</span><span>        </span><span style="color:#a626a4">return</span><span> parcelStatus  
</span>    }  
<!-- -->  
<span>    </span><span class="hljs-function" style="color:#a626a4">fun</span><span class="hljs-function"> </span><span class="hljs-function" style="color:#4078f2">updateParcelStatus</span><span class="hljs-function hljs-params">(registerSuccess: </span><span class="hljs-function hljs-params" style="color:#986801">Boolean</span><span class="hljs-function hljs-params">)</span><span> {  
</span>        parcelStatus = registerSuccess  
<!-- -->    }  
<!-- -->}</code></div></pre>
<pre><div node="[object Object]" style="display:block;overflow-x:auto;padding:0.5em;color:#383a42;background:#fafafa"><code class="language-kotlin" style="white-space:pre"><span style="color:#4078f2">@Service</span><span>  
</span><span></span><span class="hljs-class" style="color:#a626a4">class</span><span class="hljs-class"> </span><span class="hljs-class" style="color:#4078f2">OrderStatusService</span><span>(  
</span><span>    </span><span style="color:#a626a4">private</span><span> </span><span style="color:#a626a4">val</span><span> orderRepository: OrderRepository,  
</span>) {  
<!-- -->    
<span>    </span><span style="color:#4078f2">@Transactional</span><span>  
</span><span>    </span><span class="hljs-function" style="color:#a626a4">fun</span><span class="hljs-function"> </span><span class="hljs-function" style="color:#4078f2">checkOrderSubmissionStatus</span><span class="hljs-function hljs-params">(message: </span><span class="hljs-function hljs-params" style="color:#986801">OutSourcingResultMessage</span><span class="hljs-function hljs-params">)</span><span> {  
</span><span>        </span><span style="color:#a626a4">val</span><span> order = orderRepository.findByShippingLabel(message.shippingLabel)  
</span>        order.updateParcelStatus(message.registerSuccess)  
<!-- -->    }  
<!-- -->}</code></div></pre>
<pre><div node="[object Object]" style="display:block;overflow-x:auto;padding:0.5em;color:#383a42;background:#fafafa"><code class="language-kotlin" style="white-space:pre"><span style="color:#4078f2">@SpringBootTest</span><span>  
</span><span></span><span class="hljs-class" style="color:#a626a4">class</span><span class="hljs-class"> </span><span class="hljs-class" style="color:#4078f2">OrderStatusChangeServiceTest</span><span class="hljs-class"> </span><span class="hljs-class" style="color:#4078f2">@Autowired</span><span class="hljs-class"> </span><span class="hljs-class" style="color:#a626a4">constructor</span><span>(  
</span><span>    </span><span style="color:#a626a4">private</span><span> </span><span style="color:#a626a4">val</span><span> orderStatusService: OrderStatusService,  
</span><span>    </span><span style="color:#a626a4">private</span><span> </span><span style="color:#a626a4">val</span><span> orderRepository: OrderRepository,  
</span>) {  
<!-- -->  
<span>    </span><span style="color:#4078f2">@Test</span><span>  
</span><span>    </span><span style="color:#4078f2">@DisplayName(</span><span style="color:#50a14f">&quot;송장접수에 실패하면 택배등록 여부를 실패 표시 해야한다.&quot;</span><span style="color:#4078f2">)</span><span>  
</span><span>    </span><span class="hljs-function" style="color:#a626a4">fun</span><span class="hljs-function"> </span><span class="hljs-function" style="color:#4078f2">checkOrderSubmissionStatusTest</span><span class="hljs-function hljs-params">()</span><span> {  
</span><span>        </span><span style="color:#a626a4">val</span><span> order = Order(shippingLabel = </span><span style="color:#50a14f">&quot;12345&quot;</span><span>)  
</span><span>        </span><span style="color:#a626a4">val</span><span> savedOrder = orderRepository.save(order)  
</span><span>        </span><span style="color:#a626a4">val</span><span> failureMessage = OutSourcingResultMessage(  
</span>            shippingLabel = savedOrder.shippingLabel,  
<span>            registerSuccess = </span><span style="color:#0184bb">false</span><span>  
</span>        )  
<!-- -->  
<!-- -->        orderStatusService.checkOrderSubmissionStatus(failureMessage)  
<!-- -->  
<span>        order.isParcelRegister() shouldBe </span><span style="color:#0184bb">false</span><span>  
</span>    }  
<!-- -->}</code></div></pre>
<p>OrderStatusChangeService의 checkOrderSubmissionStatus(failureMessage) 메서드에 <code node="[object Object]">@Transactional</code>이 걸려있고 order의 <code node="[object Object]">parcelStatus</code>를 true에서 <strong>false</strong>로 변경한다.</p>
<p>이때 JPA 더티 체킹을 활용하여 데이터베이스 컬럼값을 변경하기 때문에 checkOrderSubmissionStatus 메서드가 종료되는 시점에 checkOrderSubmissionstatus의 트랜잭션이 커밋 되면서 영속성 컨텍스트의 변경 사항이 데이터베이스로 flush 될 것이기 때문에 테스트는 성공할 것이라 예상된다.</p>
<p>하지만 테스트 실행 결과, 테스트가 실패한 것을 확인할 수 있었다.</p>
<p><img src="https://i.imgur.com/lTvSdwQ.png" alt="[스크린샷 2024-01-06 오후 9.20.22.png]" node="[object Object]" style="max-height:450px;max-width:90%"/></p>
<p>이때 checkOrderSubmissionStatus를 호출하는 테스트 코드에 <code node="[object Object]">@Transactional</code>을 걸어주면 테스트는 성공한다.</p>
<p>왜 테스트 코드의 <code node="[object Object]">@Transactional</code> 여부에 따라서 테스트 결과가 달라지는 것일까?</p>
<h2>테스트 코드의 엔티티는 영속성 컨텍스트에 관리되지 않는다</h2>
<p>스프링 컨테이너는 기본적으로 트랜잭션 범위의 영속성 컨텍스트 전략을 사용한다.</p>
<p>즉, 트랜잭션 범위와 영속성 컨텍스트의 생명 주기가 같다는 뜻으로 트랜잭션을 시작할 때 영속성 컨텍스트를 생성하고 트랜잭션 커밋 시점에 영속성 컨텍스트를 flush하고 종료한다.</p>
<pre><div node="[object Object]" style="display:block;overflow-x:auto;padding:0.5em;color:#383a42;background:#fafafa"><code class="language-kotlin" style="white-space:pre"><span style="color:#4078f2">@SpringBootTest</span><span>  
</span><span></span><span class="hljs-class" style="color:#a626a4">class</span><span class="hljs-class"> </span><span class="hljs-class" style="color:#4078f2">OrderStatusChangeServiceTest</span><span class="hljs-class"> </span><span class="hljs-class" style="color:#4078f2">@Autowired</span><span class="hljs-class"> </span><span class="hljs-class" style="color:#a626a4">constructor</span><span>(  
</span><span>    </span><span style="color:#a626a4">private</span><span> </span><span style="color:#a626a4">val</span><span> orderStatusService: OrderStatusService,  
</span><span>    </span><span style="color:#a626a4">private</span><span> </span><span style="color:#a626a4">val</span><span> orderRepository: OrderRepository,  
</span><span>    </span><span style="color:#a626a4">private</span><span> </span><span style="color:#a626a4">val</span><span> entityManager: EntityManager,  
</span>) {  
<!-- -->  
<span>    </span><span style="color:#4078f2">@Test</span><span>  
</span><span>    </span><span style="color:#4078f2">@DisplayName(</span><span style="color:#50a14f">&quot;송장접수에 실패하면 택배등록 여부를 실패 표시 해야한다.&quot;</span><span style="color:#4078f2">)</span><span>  
</span><span>    </span><span class="hljs-function" style="color:#a626a4">fun</span><span class="hljs-function"> </span><span class="hljs-function" style="color:#4078f2">checkOrderSubmissionStatusTest</span><span class="hljs-function hljs-params">()</span><span> {  
</span><span>        </span><span style="color:#a626a4">val</span><span> order = Order(shippingLabel = </span><span style="color:#50a14f">&quot;12345&quot;</span><span>)  
</span><span>        </span><span style="color:#a626a4">val</span><span> savedOrder = orderRepository.save(order)  
</span><span>        </span><span style="color:#a626a4">val</span><span> failureMessage = OutSourcingResultMessage(  
</span>            shippingLabel = savedOrder.shippingLabel,  
<span>            registerSuccess = </span><span style="color:#0184bb">false</span><span>  
</span>        )  
<!-- -->  
<span>        println(entityManager.contains(savedOrder)) </span><span style="color:#a0a1a7;font-style:italic">// false  </span><span>
</span>        orderStatusService.checkOrderSubmissionStatus(failureMessage)  
<!-- -->  
<span>        order.isParcelRegister() shouldBe </span><span style="color:#0184bb">false</span><span>  
</span>    }  
<!-- -->}</code></div></pre>
<p>위의 결과에서 볼 수 있듯 테스트 코드의 엔티티는 트랜잭션 범위 밖이기 때문에 영속성 컨텍스트에 등록이 되어있지 않다. <code node="[object Object]">checkOrderSubmissionStatus</code> 메서드 내에서 조회해 온 Order는 트랜잭션 범위이기 때문에 영속성 컨텍스트에 의해 관리되고 있지만 테스트 코드에서 검증의 대상이 되는 Order는 트랜잭션 범위 밖에서 조회된, <strong>영속성 컨텍스트에 의해 관리되지 않는</strong> Order를 대상으로 데이터 변경 <strong>검증이 이루어진다</strong>.</p>
<p>때문에 실제 데이터베이스의 컬럼값은 의도한 대로 true에서 false로 변경되었지만, 테스트 코드의 Order는
영속성 컨텍스트의 1차 캐시에 관리되지 않기 때문에 당연하게도 더티 체킹의 효과를 볼 수 없는 것이다.</p>
<p>테스트 코드에 <code node="[object Object]">@Transactional</code>을 붙여준다면 테스트 코드의 엔티티가 영속성 컨텍스트에 의해 관리되게 되고 1차 캐시에 의해 더티 체킹 대상이 되기 때문에 테스트가 성공하게 된다.</p>
<h2>JpaTransactionManager는 트랜잭션 단위로 EntityManager를 관리한다</h2>
<p>위 사례를 통해서 더티 체킹은 영속성 컨텍스트가 관리하는 영속 상태의 엔티티에만 적용되며, 영속성 컨텍스트는 트랜잭션 단위로 생성, 삭제된다는 것을 알 수 있었다.</p>
<p>JPA가 트랜잭션 단위로 영속성 컨텍스트를 생성, 관리하는 부분의 코드를 한번 살펴보았다.</p>
<p>먼저 스프링의 표준 트랙잭션 워크플로우를 구현하는 <code node="[object Object]">AbstractPlatformTransactionManager</code> 클래스를 살펴보면 <code node="[object Object]">startTransaction()</code> 메서드에서
<code node="[object Object]">TransactionManager</code>의 <code node="[object Object]">doBegin()</code> 메서드를 호출하는것을 볼 수 있다.</p>
<p><img src="https://i.imgur.com/l4sY5Fz.png" alt="[스크린샷 2024-01-07 오후 6.59.49.png]" node="[object Object]" style="max-height:450px;max-width:90%"/></p>
<p><code node="[object Object]">doBegin()</code> 메서드는 <code node="[object Object]">TransactionManager</code>를 구현하는 <code node="[object Object]">JpaTransactionManager</code>에서 확인할 수 있다.</p>
<p><img src="https://i.imgur.com/7Qm3pOV.png" alt="[스크린샷 2024-01-07 오후 7.26.00.png]" node="[object Object]" style="max-height:450px;max-width:90%"/></p>
<p>이때  새로 시작된 트랜잭션이라면 EntityManager를 생성하고 <code node="[object Object]">JpaTransactionObject</code>에 저장한다.</p>
<p><code node="[object Object]">JpaTransactionObject</code>는 현재 트랜잭션의 상태를 추적하는 데 사용되며, 트랜잭션 범위 내에서 사용되는 EntityManager를 <code node="[object Object]">EntityManagerHolder</code>를 통해서 관리하고 있다.</p>
<p>이러한 로직을 통해서 트랜잭션 범위 내에서 동일한 EntityManager가 사용될 수 있던 것이다.</p>
<h2>마무리</h2>
<p>지금까지 트랜잭션 범위와 영속성 컨텍스트의 생명 주기가 어떻게 관리되는지 알아보았다.</p>
<p>사실 영속성 컨텍스트의 생존 범위가 항상 트랜잭션 범위내인 것은 아니다.
OSIV(Open Session In View)를 사용하면 영속성 컨텍스트의 범위를 트랜잭션 범위 밖까지 확장 할 수 있다.</p></div><section></section></div></main></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"postData":{"id":"post2-2","title":"JPA 트랜잭션과 영속성 컨텍스트","category":null,"thumbnail":"https://images.velog.io/images/dnjscksdn98/post/14072bd8-850b-4d2b-8476-cb5385bbcd36/jpa.png","tags":"JPA","date":"2024-01-07 10:00","searchKeywords":"jpa, entitymanager, 영속성 컨텍스트, 트랜잭션","description":"JPA 트랜잭션과 영속성 컨텍스트","preview":"\n최근 구현한 테스트 코드에서 `@Transactional` 여부에 따라 테스트 결과가 달라지는 문제를 만나게 되었다.\n\n타 서비스로부터 송장 접수 결과에 대한 카프카 메세지를 소비한 다음, 송장 접수에 실패했다면 택배 등록 여부를 실패로 변경하는 로"},"detail":"\n최근 구현한 테스트 코드에서 `@Transactional` 여부에 따라 테스트 결과가 달라지는 문제를 만나게 되었다.\n\n타 서비스로부터 송장 접수 결과에 대한 카프카 메세지를 소비한 다음, 송장 접수에 실패했다면 택배 등록 여부를 실패로 변경하는 로직에 대한 테스트 코드였는데 당시 상황을 간단하게 재현해 보았다.\n\n```kotlin\n@Entity  \n@Table(name = \"orders\")  \nclass Order (  \n    val shippingLabel: String,  \n    var parcelStatus: Boolean = true,  \n  \n    @Id  \n    @GeneratedValue(strategy = GenerationType.IDENTITY)  \n    val id: Long? = null,  \n) {  \n    fun isParcelRegister(): Boolean {  \n        return parcelStatus  \n    }  \n  \n    fun updateParcelStatus(registerSuccess: Boolean) {  \n        parcelStatus = registerSuccess  \n    }  \n}\n```\n\n```kotlin\n@Service  \nclass OrderStatusService(  \n    private val orderRepository: OrderRepository,  \n) {  \n    \n    @Transactional  \n    fun checkOrderSubmissionStatus(message: OutSourcingResultMessage) {  \n        val order = orderRepository.findByShippingLabel(message.shippingLabel)  \n        order.updateParcelStatus(message.registerSuccess)  \n    }  \n}\n```\n\n```kotlin\n@SpringBootTest  \nclass OrderStatusChangeServiceTest @Autowired constructor(  \n    private val orderStatusService: OrderStatusService,  \n    private val orderRepository: OrderRepository,  \n) {  \n  \n    @Test  \n    @DisplayName(\"송장접수에 실패하면 택배등록 여부를 실패 표시 해야한다.\")  \n    fun checkOrderSubmissionStatusTest() {  \n        val order = Order(shippingLabel = \"12345\")  \n        val savedOrder = orderRepository.save(order)  \n        val failureMessage = OutSourcingResultMessage(  \n            shippingLabel = savedOrder.shippingLabel,  \n            registerSuccess = false  \n        )  \n  \n        orderStatusService.checkOrderSubmissionStatus(failureMessage)  \n  \n        order.isParcelRegister() shouldBe false  \n    }  \n}\n```\n\nOrderStatusChangeService의 checkOrderSubmissionStatus(failureMessage) 메서드에 `@Transactional`이 걸려있고 order의 `parcelStatus`를 true에서 **false**로 변경한다.\n\n이때 JPA 더티 체킹을 활용하여 데이터베이스 컬럼값을 변경하기 때문에 checkOrderSubmissionStatus 메서드가 종료되는 시점에 checkOrderSubmissionstatus의 트랜잭션이 커밋 되면서 영속성 컨텍스트의 변경 사항이 데이터베이스로 flush 될 것이기 때문에 테스트는 성공할 것이라 예상된다.\n\n하지만 테스트 실행 결과, 테스트가 실패한 것을 확인할 수 있었다.\n\n![[스크린샷 2024-01-06 오후 9.20.22.png]](https://i.imgur.com/lTvSdwQ.png)\n\n이때 checkOrderSubmissionStatus를 호출하는 테스트 코드에 `@Transactional`을 걸어주면 테스트는 성공한다.\n\n왜 테스트 코드의 `@Transactional` 여부에 따라서 테스트 결과가 달라지는 것일까?\n## 테스트 코드의 엔티티는 영속성 컨텍스트에 관리되지 않는다\n\n스프링 컨테이너는 기본적으로 트랜잭션 범위의 영속성 컨텍스트 전략을 사용한다.\n\n즉, 트랜잭션 범위와 영속성 컨텍스트의 생명 주기가 같다는 뜻으로 트랜잭션을 시작할 때 영속성 컨텍스트를 생성하고 트랜잭션 커밋 시점에 영속성 컨텍스트를 flush하고 종료한다.\n\n```kotlin\n@SpringBootTest  \nclass OrderStatusChangeServiceTest @Autowired constructor(  \n    private val orderStatusService: OrderStatusService,  \n    private val orderRepository: OrderRepository,  \n    private val entityManager: EntityManager,  \n) {  \n  \n    @Test  \n    @DisplayName(\"송장접수에 실패하면 택배등록 여부를 실패 표시 해야한다.\")  \n    fun checkOrderSubmissionStatusTest() {  \n        val order = Order(shippingLabel = \"12345\")  \n        val savedOrder = orderRepository.save(order)  \n        val failureMessage = OutSourcingResultMessage(  \n            shippingLabel = savedOrder.shippingLabel,  \n            registerSuccess = false  \n        )  \n  \n        println(entityManager.contains(savedOrder)) // false  \n        orderStatusService.checkOrderSubmissionStatus(failureMessage)  \n  \n        order.isParcelRegister() shouldBe false  \n    }  \n}\n```\n\n위의 결과에서 볼 수 있듯 테스트 코드의 엔티티는 트랜잭션 범위 밖이기 때문에 영속성 컨텍스트에 등록이 되어있지 않다. `checkOrderSubmissionStatus` 메서드 내에서 조회해 온 Order는 트랜잭션 범위이기 때문에 영속성 컨텍스트에 의해 관리되고 있지만 테스트 코드에서 검증의 대상이 되는 Order는 트랜잭션 범위 밖에서 조회된, **영속성 컨텍스트에 의해 관리되지 않는** Order를 대상으로 데이터 변경 **검증이 이루어진다**.\n\n때문에 실제 데이터베이스의 컬럼값은 의도한 대로 true에서 false로 변경되었지만, 테스트 코드의 Order는\n영속성 컨텍스트의 1차 캐시에 관리되지 않기 때문에 당연하게도 더티 체킹의 효과를 볼 수 없는 것이다.\n\n테스트 코드에 `@Transactional`을 붙여준다면 테스트 코드의 엔티티가 영속성 컨텍스트에 의해 관리되게 되고 1차 캐시에 의해 더티 체킹 대상이 되기 때문에 테스트가 성공하게 된다.\n## JpaTransactionManager는 트랜잭션 단위로 EntityManager를 관리한다\n\n위 사례를 통해서 더티 체킹은 영속성 컨텍스트가 관리하는 영속 상태의 엔티티에만 적용되며, 영속성 컨텍스트는 트랜잭션 단위로 생성, 삭제된다는 것을 알 수 있었다.\n\nJPA가 트랜잭션 단위로 영속성 컨텍스트를 생성, 관리하는 부분의 코드를 한번 살펴보았다.\n\n먼저 스프링의 표준 트랙잭션 워크플로우를 구현하는 `AbstractPlatformTransactionManager` 클래스를 살펴보면 `startTransaction()` 메서드에서 \n`TransactionManager`의 `doBegin()` 메서드를 호출하는것을 볼 수 있다.\n\n![[스크린샷 2024-01-07 오후 6.59.49.png]](https://i.imgur.com/l4sY5Fz.png)\n\n`doBegin()` 메서드는 `TransactionManager`를 구현하는 `JpaTransactionManager`에서 확인할 수 있다.\n\n![[스크린샷 2024-01-07 오후 7.26.00.png]](https://i.imgur.com/7Qm3pOV.png)\n\n이때  새로 시작된 트랜잭션이라면 EntityManager를 생성하고 `JpaTransactionObject`에 저장한다.\n\n`JpaTransactionObject`는 현재 트랜잭션의 상태를 추적하는 데 사용되며, 트랜잭션 범위 내에서 사용되는 EntityManager를 `EntityManagerHolder`를 통해서 관리하고 있다.\n\n이러한 로직을 통해서 트랜잭션 범위 내에서 동일한 EntityManager가 사용될 수 있던 것이다.\n\n## 마무리\n\n지금까지 트랜잭션 범위와 영속성 컨텍스트의 생명 주기가 어떻게 관리되는지 알아보았다.\n\n사실 영속성 컨텍스트의 생존 범위가 항상 트랜잭션 범위내인 것은 아니다.\nOSIV(Open Session In View)를 사용하면 영속성 컨텍스트의 범위를 트랜잭션 범위 밖까지 확장 할 수 있다."},"__N_SSG":true},"page":"/[id]","query":{"id":"post2-2"},"buildId":"rHHwQgn4XzsFFzcKqsKPc","assetPrefix":"/TIL","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>